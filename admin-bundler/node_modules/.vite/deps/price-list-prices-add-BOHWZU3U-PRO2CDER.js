import {
  PriceListCreateProductsSchema,
  usePriceListCurrencyData,
  usePriceListGridColumns
} from "./chunk-XEJTKOPT.js";
import {
  exctractPricesFromProducts,
  isProductRow
} from "./chunk-B6OHAYH3.js";
import "./chunk-KXUBVGOF.js";
import {
  useProductTableColumns
} from "./chunk-BOUEFVQ5.js";
import "./chunk-B76TY3YZ.js";
import "./chunk-XKOLLBFA.js";
import {
  DataGrid
} from "./chunk-IW7WG74X.js";
import "./chunk-55MYIBGD.js";
import "./chunk-4TA2GWZH.js";
import {
  useProductTableQuery
} from "./chunk-HV4CT7SS.js";
import {
  useProductTableFilters
} from "./chunk-3LONSD4H.js";
import "./chunk-EGRHWZRV.js";
import "./chunk-QZUCBNNJ.js";
import {
  DataTable,
  useDataTable
} from "./chunk-JH6E7Y6M.js";
import "./chunk-EIGZCZHJ.js";
import "./chunk-CEIAMOT7.js";
import "./chunk-EYAVSJ2J.js";
import {
  createColumnHelper
} from "./chunk-TI6Y7EUW.js";
import "./chunk-JEFCFQ36.js";
import "./chunk-Z74QHE3B.js";
import "./chunk-6VC5CKXS.js";
import "./chunk-4HJQONUH.js";
import "./chunk-IANM7SMM.js";
import "./chunk-LKYIPMJI.js";
import {
  RouteFocusModal,
  useRouteModal
} from "./chunk-3P6F4Q7W.js";
import "./chunk-7PAMQDEU.js";
import "./chunk-O47TKOMU.js";
import "./chunk-E26TGYVV.js";
import "./chunk-BCDFWL4W.js";
import "./chunk-VOJT3GRC.js";
import "./chunk-4I3TSILH.js";
import "./chunk-P5R3EHIV.js";
import "./chunk-2TBOMIQA.js";
import "./chunk-7VADNSL7.js";
import "./chunk-AJ3DXG4K.js";
import "./chunk-FYV5O3WI.js";
import "./chunk-ENW5Z6NU.js";
import "./chunk-MKU523AN.js";
import "./chunk-EFAG6P6Z.js";
import "./chunk-NJ7HRVAN.js";
import {
  useBatchPriceListPrices,
  usePriceList
} from "./chunk-KNWZIBC3.js";
import "./chunk-5RUNMRCW.js";
import "./chunk-CFFZHLR2.js";
import "./chunk-YEEFU7KP.js";
import "./chunk-6MTGJSDM.js";
import "./chunk-Z34GYBFG.js";
import "./chunk-VN2HND4I.js";
import "./chunk-ACJP53PC.js";
import "./chunk-3AX2W3RD.js";
import "./chunk-ICPBA7GK.js";
import "./chunk-FREJU5EQ.js";
import "./chunk-4UBJQZN6.js";
import "./chunk-QSXBBOKN.js";
import "./chunk-YSLQHU2M.js";
import "./chunk-RLHQ5IGU.js";
import "./chunk-HZGR4LPF.js";
import "./chunk-3FGSU2DA.js";
import "./chunk-YUBPGLTM.js";
import "./chunk-K4BQKT4B.js";
import "./chunk-SWXOOP7W.js";
import "./chunk-ROURSU5C.js";
import "./chunk-ABZDCU5X.js";
import {
  useProducts
} from "./chunk-3VJMO5NN.js";
import "./chunk-IH74SCJ5.js";
import "./chunk-4UMAAWOP.js";
import "./chunk-Y5OEN2X7.js";
import {
  t
} from "./chunk-NMISSY3S.js";
import {
  z
} from "./chunk-D6YTPD33.js";
import {
  useForm,
  useWatch
} from "./chunk-TKBVWLOU.js";
import "./chunk-2ZDF4QRQ.js";
import "./chunk-QDFILGGU.js";
import {
  keepPreviousData
} from "./chunk-ZSXFNTF6.js";
import {
  Button,
  Checkbox,
  ProgressTabs,
  Tooltip,
  toast,
  useTranslation
} from "./chunk-ZUPX4YFG.js";
import {
  useParams
} from "./chunk-HTGWU6KF.js";
import "./chunk-64MXM5QD.js";
import "./chunk-3VI6QF3M.js";
import {
  require_jsx_runtime
} from "./chunk-P6CFP5BP.js";
import {
  __toESM,
  require_react
} from "./chunk-H5NG3XTT.js";

// node_modules/@medusajs/dashboard/dist/price-list-prices-add-BOHWZU3U.mjs
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var PriceListPricesAddPricesForm = ({
  form,
  currencies,
  regions,
  pricePreferences
}) => {
  const ids = useWatch({
    control: form.control,
    name: "product_ids"
  });
  const existingProducts = useWatch({
    control: form.control,
    name: "products"
  });
  const { products, isLoading, isError, error } = useProducts({
    id: ids.map((id) => id.id),
    limit: ids.length,
    fields: "title,thumbnail,*variants"
  });
  const { setValue } = form;
  const { setCloseOnEscape } = useRouteModal();
  (0, import_react2.useEffect)(() => {
    if (!isLoading && products) {
      products.forEach((product) => {
        if (existingProducts[product.id] || !product.variants) {
          return;
        }
        setValue(`products.${product.id}.variants`, {
          ...product.variants.reduce((variants, variant) => {
            variants[variant.id] = {
              currency_prices: {},
              region_prices: {}
            };
            return variants;
          }, {})
        });
      });
    }
  }, [products, existingProducts, isLoading, setValue]);
  const columns = usePriceListGridColumns({
    currencies,
    regions,
    pricePreferences
  });
  if (isError) {
    throw error;
  }
  return (0, import_jsx_runtime.jsx)("div", { className: "flex size-full flex-col divide-y overflow-hidden", children: (0, import_jsx_runtime.jsx)(
    DataGrid,
    {
      isLoading,
      columns,
      data: products,
      getSubRows: (row) => {
        if (isProductRow(row) && row.variants) {
          return row.variants;
        }
      },
      state: form,
      onEditingChange: (editing) => setCloseOnEscape(!editing)
    }
  ) });
};
var PAGE_SIZE = 50;
var PREFIX = "p";
function getInitialSelection(products) {
  return products.reduce((acc, curr) => {
    acc[curr.id] = true;
    return acc;
  }, {});
}
var PriceListPricesAddProductIdsForm = ({
  priceList,
  form
}) => {
  const { control, setValue } = form;
  const variantIdMap = (0, import_react3.useMemo)(() => {
    return priceList.prices.reduce((acc, curr) => {
      acc[curr.variant_id] = true;
      return acc;
    }, {});
  }, [priceList.prices]);
  const selectedIds = useWatch({
    control,
    name: "product_ids"
  });
  const productRecords = useWatch({
    control,
    name: "products"
  });
  const [rowSelection, setRowSelection] = (0, import_react3.useState)(
    getInitialSelection(selectedIds)
  );
  const { searchParams, raw } = useProductTableQuery({
    pageSize: PAGE_SIZE,
    prefix: PREFIX
  });
  const { products, count, isLoading, isError, error } = useProducts(
    searchParams,
    {
      placeholderData: keepPreviousData
    }
  );
  const updater = (fn) => {
    const state = typeof fn === "function" ? fn(rowSelection) : fn;
    const ids = Object.keys(state);
    const productRecordKeys = Object.keys(productRecords);
    const updatedRecords = productRecordKeys.reduce((acc, key) => {
      if (ids.includes(key)) {
        acc[key] = productRecords[key];
      }
      return acc;
    }, {});
    const update = ids.map((id) => ({ id }));
    setValue("product_ids", update, { shouldDirty: true, shouldTouch: true });
    setValue("products", updatedRecords, {
      shouldDirty: true,
      shouldTouch: true
    });
    setRowSelection(state);
  };
  const columns = useColumns();
  const filters = useProductTableFilters();
  const { table } = useDataTable({
    data: products || [],
    columns,
    count,
    enablePagination: true,
    enableRowSelection: (row) => {
      var _a, _b;
      return !!((_a = row.original.variants) == null ? void 0 : _a.length) && !((_b = row.original.variants) == null ? void 0 : _b.some((v) => variantIdMap[v.id]));
    },
    getRowId: (row) => row.id,
    rowSelection: {
      state: rowSelection,
      updater
    },
    pageSize: PAGE_SIZE,
    meta: {
      variantIdMap
    }
  });
  if (isError) {
    throw error;
  }
  return (0, import_jsx_runtime2.jsx)("div", { className: "flex size-full flex-col", children: (0, import_jsx_runtime2.jsx)(
    DataTable,
    {
      table,
      columns,
      filters,
      pageSize: PAGE_SIZE,
      prefix: PREFIX,
      count,
      isLoading,
      layout: "fill",
      orderBy: ["title", "status", "created_at", "updated_at"],
      pagination: true,
      search: true,
      queryObject: raw
    }
  ) });
};
var columnHelper = createColumnHelper();
var useColumns = () => {
  const base = useProductTableColumns();
  return (0, import_react3.useMemo)(
    () => [
      columnHelper.display({
        id: "select",
        header: ({ table }) => {
          return (0, import_jsx_runtime2.jsx)(
            Checkbox,
            {
              checked: table.getIsSomePageRowsSelected() ? "indeterminate" : table.getIsAllPageRowsSelected(),
              onCheckedChange: (value) => table.toggleAllPageRowsSelected(!!value)
            }
          );
        },
        cell: ({ row, table }) => {
          var _a;
          const { variantIdMap } = table.options.meta;
          const isPreselected = (_a = row.original.variants) == null ? void 0 : _a.some(
            (v) => variantIdMap[v.id]
          );
          const isDisabled = !row.getCanSelect() || isPreselected;
          const isChecked = row.getIsSelected() || isPreselected;
          const Component = (0, import_jsx_runtime2.jsx)(
            Checkbox,
            {
              checked: isChecked,
              disabled: isDisabled,
              onCheckedChange: (value) => row.toggleSelected(!!value),
              onClick: (e) => {
                e.stopPropagation();
              }
            }
          );
          if (isPreselected) {
            return (0, import_jsx_runtime2.jsx)(Tooltip, { content: "This product is already in the price list", children: Component });
          }
          if (isDisabled) {
            return (0, import_jsx_runtime2.jsx)(Tooltip, { content: "This product has no variants", children: Component });
          }
          return Component;
        }
      }),
      ...base
    ],
    [base]
  );
};
var PriceListPricesAddSchema = z.object({
  product_ids: z.array(z.object({ id: z.string() })).min(1),
  products: PriceListCreateProductsSchema
});
var PriceListPricesAddProductIdsSchema = PriceListPricesAddSchema.pick(
  {
    product_ids: true
  }
);
var PriceListPricesAddProductsIdsFields = Object.keys(
  PriceListPricesAddProductIdsSchema.shape
);
var PriceListPricesAddProductsSchema = PriceListPricesAddSchema.pick({
  products: true
});
var PriceListPricesAddProductsFields = Object.keys(
  PriceListPricesAddProductsSchema.shape
);
var tabOrder = [
  "product",
  "price"
  /* PRICE */
];
var initialTabState = {
  [
    "product"
    /* PRODUCT */
  ]: "in-progress",
  [
    "price"
    /* PRICE */
  ]: "not-started"
};
var PriceListPricesAddForm = ({
  priceList,
  regions,
  currencies,
  pricePreferences
}) => {
  const [tab, setTab] = (0, import_react.useState)(
    "product"
    /* PRODUCT */
  );
  const [tabState, setTabState] = (0, import_react.useState)(initialTabState);
  const { t: t2 } = useTranslation();
  const { handleSuccess } = useRouteModal();
  const form = useForm({
    defaultValues: {
      products: {},
      product_ids: []
    },
    resolver: t(PriceListPricesAddSchema)
  });
  const { mutateAsync, isPending } = useBatchPriceListPrices(priceList.id);
  const handleSubmit = form.handleSubmit(async (values) => {
    const { products } = values;
    const prices = exctractPricesFromProducts(products, regions);
    await mutateAsync(
      {
        create: prices
      },
      {
        onSuccess: () => {
          toast.success(t2("priceLists.products.add.successToast"));
          handleSuccess();
        },
        onError: (e) => toast.error(e.message)
      }
    );
  });
  const partialFormValidation = (fields, schema) => {
    form.clearErrors(fields);
    const values = fields.reduce((acc, key) => {
      acc[key] = form.getValues(key);
      return acc;
    }, {});
    const validationResult = schema.safeParse(values);
    if (!validationResult.success) {
      validationResult.error.errors.forEach(({ path, message, code }) => {
        form.setError(path.join("."), {
          type: code,
          message
        });
      });
      return false;
    }
    return true;
  };
  const isTabDirty = (tab2) => {
    switch (tab2) {
      case "product": {
        const fields = PriceListPricesAddProductsIdsFields;
        return fields.some((field) => {
          return form.getFieldState(field).isDirty;
        });
      }
      case "price": {
        const fields = PriceListPricesAddProductsFields;
        return fields.some((field) => {
          return form.getFieldState(field).isDirty;
        });
      }
    }
  };
  const handleChangeTab = (update) => {
    if (tab === update) {
      return;
    }
    if (tabOrder.indexOf(update) < tabOrder.indexOf(tab)) {
      const isCurrentTabDirty = isTabDirty(tab);
      setTabState((prev) => ({
        ...prev,
        [tab]: isCurrentTabDirty ? prev[tab] : "not-started",
        [update]: "in-progress"
      }));
      setTab(update);
      return;
    }
    const tabs = tabOrder.slice(0, tabOrder.indexOf(update));
    for (const tab2 of tabs) {
      if (tab2 === "product") {
        if (!partialFormValidation(
          PriceListPricesAddProductsIdsFields,
          PriceListPricesAddProductIdsSchema
        )) {
          setTabState((prev) => ({
            ...prev,
            [tab2]: "in-progress"
          }));
          setTab(tab2);
          return;
        }
        setTabState((prev) => ({
          ...prev,
          [tab2]: "completed"
        }));
      }
    }
    setTabState((prev) => ({
      ...prev,
      [tab]: "completed",
      [update]: "in-progress"
    }));
    setTab(update);
  };
  const handleNextTab = (tab2) => {
    if (tabOrder.indexOf(tab2) + 1 >= tabOrder.length) {
      return;
    }
    const nextTab = tabOrder[tabOrder.indexOf(tab2) + 1];
    handleChangeTab(nextTab);
  };
  return (0, import_jsx_runtime3.jsx)(RouteFocusModal.Form, { form, children: (0, import_jsx_runtime3.jsx)(
    ProgressTabs,
    {
      value: tab,
      onValueChange: (tab2) => handleChangeTab(tab2),
      className: "flex h-full flex-col overflow-hidden",
      children: (0, import_jsx_runtime3.jsxs)("form", { onSubmit: handleSubmit, className: "flex h-full flex-col", children: [
        (0, import_jsx_runtime3.jsx)(RouteFocusModal.Header, { children: (0, import_jsx_runtime3.jsx)("div", { className: "flex w-full items-center justify-between gap-x-4", children: (0, import_jsx_runtime3.jsx)("div", { className: "-my-2 w-full max-w-[600px] border-l", children: (0, import_jsx_runtime3.jsxs)(ProgressTabs.List, { className: "grid w-full grid-cols-3", children: [
          (0, import_jsx_runtime3.jsx)(
            ProgressTabs.Trigger,
            {
              status: tabState.product,
              value: "product",
              children: t2("priceLists.create.tabs.products")
            }
          ),
          (0, import_jsx_runtime3.jsx)(
            ProgressTabs.Trigger,
            {
              status: tabState.price,
              value: "price",
              children: t2("priceLists.create.tabs.prices")
            }
          )
        ] }) }) }) }),
        (0, import_jsx_runtime3.jsxs)(RouteFocusModal.Body, { className: "size-full overflow-hidden", children: [
          (0, import_jsx_runtime3.jsx)(
            ProgressTabs.Content,
            {
              className: "size-full overflow-y-auto",
              value: "product",
              children: (0, import_jsx_runtime3.jsx)(
                PriceListPricesAddProductIdsForm,
                {
                  form,
                  priceList
                }
              )
            }
          ),
          (0, import_jsx_runtime3.jsx)(
            ProgressTabs.Content,
            {
              className: "size-full overflow-hidden",
              value: "price",
              children: (0, import_jsx_runtime3.jsx)(
                PriceListPricesAddPricesForm,
                {
                  form,
                  regions,
                  currencies,
                  pricePreferences
                }
              )
            }
          )
        ] }),
        (0, import_jsx_runtime3.jsx)(RouteFocusModal.Footer, { children: (0, import_jsx_runtime3.jsxs)("div", { className: "flex items-center justify-end gap-x-2", children: [
          (0, import_jsx_runtime3.jsx)(RouteFocusModal.Close, { asChild: true, children: (0, import_jsx_runtime3.jsx)(Button, { variant: "secondary", size: "small", children: t2("actions.cancel") }) }),
          (0, import_jsx_runtime3.jsx)(
            PrimaryButton,
            {
              tab,
              next: handleNextTab,
              isLoading: isPending
            }
          )
        ] }) })
      ] })
    }
  ) });
};
var PrimaryButton = ({ tab, next, isLoading }) => {
  const { t: t2 } = useTranslation();
  if (tab === "price") {
    return (0, import_jsx_runtime3.jsx)(
      Button,
      {
        type: "submit",
        variant: "primary",
        size: "small",
        isLoading,
        children: t2("actions.save")
      },
      "submit-button"
    );
  }
  return (0, import_jsx_runtime3.jsx)(
    Button,
    {
      type: "button",
      variant: "primary",
      size: "small",
      onClick: () => next(tab),
      children: t2("actions.continue")
    },
    "next-button"
  );
};
var PriceListProductsAdd = () => {
  const { id } = useParams();
  const { price_list, isPending, isError, error } = usePriceList(id);
  const { currencies, regions, pricePreferences, isReady } = usePriceListCurrencyData();
  const ready = isReady && !isPending && !!price_list;
  if (isError) {
    throw error;
  }
  return (0, import_jsx_runtime4.jsx)(RouteFocusModal, { children: ready && (0, import_jsx_runtime4.jsx)(
    PriceListPricesAddForm,
    {
      priceList: price_list,
      currencies,
      regions,
      pricePreferences
    }
  ) });
};
export {
  PriceListProductsAdd as Component
};
//# sourceMappingURL=price-list-prices-add-BOHWZU3U-PRO2CDER.js.map
