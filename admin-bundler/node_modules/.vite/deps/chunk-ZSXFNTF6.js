import {
  require_jsx_runtime
} from "./chunk-P6CFP5BP.js";
import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __toESM,
  require_react
} from "./chunk-H5NG3XTT.js";

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports, module) {
    "use strict";
    module.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports, module) {
    "use strict";
    module.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports, module) {
    "use strict";
    module.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports, module) {
    "use strict";
    module.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports, module) {
    "use strict";
    module.exports = SyntaxError;
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports, module) {
    "use strict";
    module.exports = TypeError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports, module) {
    "use strict";
    module.exports = URIError;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "node_modules/has-proto/index.js"(exports, module) {
    "use strict";
    var test = {
      __proto__: null,
      foo: {}
    };
    var $Object = Object;
    module.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !(test instanceof $Object);
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports, module) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var undefined2;
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
      return x.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true) || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/define-data-property/index.js"(exports, module) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports, module) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module.exports = hasPropertyDescriptors;
  }
});

// node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "node_modules/set-function-length/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var define = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type();
    var $floor = GetIntrinsic("%Math.floor%");
    module.exports = function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length,
            true,
            true
          );
        } else {
          define(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length
          );
        }
      }
      return fn;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var setFunctionLength = require_set_function_length();
    var $TypeError = require_type();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = require_es_define_property();
    var $max = GetIntrinsic("%Math.max%");
    module.exports = function callBind(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind, $call, arguments);
      return setFunctionLength(
        func,
        1 + $max(0, originalFunction.length - (arguments.length - 1)),
        true
      );
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// (disabled):node_modules/object-inspect/util.inspect
var require_util = __commonJS({
  "(disabled):node_modules/object-inspect/util.inspect"() {
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports, module) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (typeof globalThis !== "undefined" && obj === globalThis || typeof global !== "undefined" && obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      var prev = list;
      var curr;
      for (; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = /** @type {NonNullable<typeof list.next>} */
          list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = /** @type {import('.').ListNode<typeof value>} */
        {
          // eslint-disable-line no-param-reassign, no-extra-parens
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/qs/lib/formats.js"(exports, module) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/qs/lib/utils.js
var require_utils = __commonJS({
  "node_modules/qs/lib/utils.js"(exports, module) {
    "use strict";
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var limit = 1024;
    var encode = function encode2(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];
        for (var i = 0; i < segment.length; ++i) {
          var c = segment.charCodeAt(i);
          if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
            arr[arr.length] = segment.charAt(i);
            continue;
          }
          if (c < 128) {
            arr[arr.length] = hexTable[c];
            continue;
          }
          if (c < 2048) {
            arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
            continue;
          }
          if (c < 55296 || c >= 57344) {
            arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
            continue;
          }
          i += 1;
          c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
          arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
        }
        out += arr.join("");
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key = keys[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a, b) {
      return [].concat(a, b);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    };
    module.exports = {
      arrayToObject,
      assign,
      combine,
      compact,
      decode,
      encode,
      isBuffer,
      isRegExp,
      maybeMap,
      merge
    };
  }
});

// node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/qs/lib/stringify.js"(exports, module) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      allowEmptyArrays: false,
      arrayFormat: "indices",
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encodeDotInKeys: false,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    };
    var sentinel = {};
    var stringify = function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, "%2E") : prefix;
      var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
      if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + "[]";
      }
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify2(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          allowEmptyArrays,
          strictNullHandling,
          skipNulls,
          encodeDotInKeys,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder,
          filter,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
        throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter = opts.filter;
      }
      var arrayFormat;
      if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if ("indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = defaults.arrayFormat;
      }
      if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options.filter === "function") {
        filter = options.filter;
        obj = filter("", obj);
      } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
      var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys, stringify(
          obj[key],
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.allowEmptyArrays,
          options.strictNullHandling,
          options.skipNulls,
          options.encodeDotInKeys,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "node_modules/qs/lib/parse.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowEmptyArrays: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decodeDotInKeys: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      duplicates: "combine",
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictDepth: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = { __proto__: null };
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray(val) ? [val] : val;
        }
        var existing = has.call(obj, key);
        if (existing && options.duplicates === "combine") {
          obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === "last") {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]" && options.parseArrays) {
          obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
          var index = parseInt(decodedRoot, 10);
          if (!options.parseArrays && decodedRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (decodedRoot !== "__proto__") {
            obj[decodedRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        if (options.strictDepth === true) {
          throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
        }
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
        throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
      if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
        throw new TypeError("The duplicates option must be either combine, first, or last");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "node_modules/qs/lib/index.js"(exports, module) {
    "use strict";
    var stringify = require_stringify();
    var parse = require_parse();
    var formats = require_formats();
    module.exports = {
      formats,
      parse,
      stringify
    };
  }
});

// node_modules/@tanstack/query-core/build/modern/utils.js
var isServer = typeof window === "undefined" || "Deno" in globalThis;
function noop() {
  return void 0;
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function resolveStaleTime(staleTime, query) {
  return typeof staleTime === "function" ? staleTime(query) : staleTime;
}
function resolveEnabled(enabled, query) {
  return typeof enabled === "function" ? enabled(query) : enabled;
}
function matchQuery(filters, query) {
  const {
    type = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (queryKey) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type !== "all") {
    const isActive = query.isActive();
    if (type === "active" && !isActive) {
      return false;
    }
    if (type === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const { exact, status, predicate, mutationKey } = filters;
  if (mutationKey) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (status && mutation.state.status !== status) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options) {
  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashKey;
  return hashFn(queryKey);
}
function hashKey(queryKey) {
  return JSON.stringify(
    queryKey,
    (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {
      result[key] = val[key];
      return result;
    }, {}) : val
  );
}
function partialMatchKey(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (a && b && typeof a === "object" && typeof b === "object") {
    return !Object.keys(b).some((key) => !partialMatchKey(a[key], b[key]));
  }
  return false;
}
function replaceEqualDeep(a, b) {
  if (a === b) {
    return a;
  }
  const array = isPlainArray(a) && isPlainArray(b);
  if (array || isPlainObject(a) && isPlainObject(b)) {
    const aItems = array ? a : Object.keys(a);
    const aSize = aItems.length;
    const bItems = array ? b : Object.keys(b);
    const bSize = bItems.length;
    const copy = array ? [] : {};
    let equalItems = 0;
    for (let i = 0; i < bSize; i++) {
      const key = array ? i : bItems[i];
      if ((!array && aItems.includes(key) || array) && a[key] === void 0 && b[key] === void 0) {
        copy[key] = void 0;
        equalItems++;
      } else {
        copy[key] = replaceEqualDeep(a[key], b[key]);
        if (copy[key] === a[key] && a[key] !== void 0) {
          equalItems++;
        }
      }
    }
    return aSize === bSize && equalItems === aSize ? a : copy;
  }
  return b;
}
function shallowEqualObjects(a, b) {
  if (!b || Object.keys(a).length !== Object.keys(b).length) {
    return false;
  }
  for (const key in a) {
    if (a[key] !== b[key]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  }
  const ctor = o.constructor;
  if (ctor === void 0) {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  if (Object.getPrototypeOf(o) !== Object.prototype) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function sleep(timeout) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeout);
  });
}
function replaceData(prevData, data, options) {
  if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data);
  } else if (options.structuralSharing !== false) {
    if (true) {
      try {
        return replaceEqualDeep(prevData, data);
      } catch (error) {
        console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options.queryHash}]: ${error}`
        );
      }
    }
    return replaceEqualDeep(prevData, data);
  }
  return data;
}
function keepPreviousData(previousData) {
  return previousData;
}
function addToEnd(items, item, max = 0) {
  const newItems = [...items, item];
  return max && newItems.length > max ? newItems.slice(1) : newItems;
}
function addToStart(items, item, max = 0) {
  const newItems = [item, ...items];
  return max && newItems.length > max ? newItems.slice(0, -1) : newItems;
}
var skipToken = Symbol();
function ensureQueryFn(options, fetchOptions) {
  if (true) {
    if (options.queryFn === skipToken) {
      console.error(
        `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options.queryHash}'`
      );
    }
  }
  if (!options.queryFn && (fetchOptions == null ? void 0 : fetchOptions.initialPromise)) {
    return () => fetchOptions.initialPromise;
  }
  if (!options.queryFn || options.queryFn === skipToken) {
    return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));
  }
  return options.queryFn;
}

// node_modules/@tanstack/query-core/build/modern/subscribable.js
var Subscribable = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.add(listener);
    this.onSubscribe();
    return () => {
      this.listeners.delete(listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
};

// node_modules/@tanstack/query-core/build/modern/focusManager.js
var _focused, _cleanup, _setup, _a;
var FocusManager = (_a = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _focused);
    __privateAdd(this, _cleanup);
    __privateAdd(this, _setup);
    __privateSet(this, _setup, (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup)) {
      this.setEventListener(__privateGet(this, _setup));
    }
  }
  onUnsubscribe() {
    var _a11;
    if (!this.hasListeners()) {
      (_a11 = __privateGet(this, _cleanup)) == null ? void 0 : _a11.call(this);
      __privateSet(this, _cleanup, void 0);
    }
  }
  setEventListener(setup) {
    var _a11;
    __privateSet(this, _setup, setup);
    (_a11 = __privateGet(this, _cleanup)) == null ? void 0 : _a11.call(this);
    __privateSet(this, _cleanup, setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    }));
  }
  setFocused(focused) {
    const changed = __privateGet(this, _focused) !== focused;
    if (changed) {
      __privateSet(this, _focused, focused);
      this.onFocus();
    }
  }
  onFocus() {
    const isFocused = this.isFocused();
    this.listeners.forEach((listener) => {
      listener(isFocused);
    });
  }
  isFocused() {
    var _a11;
    if (typeof __privateGet(this, _focused) === "boolean") {
      return __privateGet(this, _focused);
    }
    return ((_a11 = globalThis.document) == null ? void 0 : _a11.visibilityState) !== "hidden";
  }
}, _focused = new WeakMap(), _cleanup = new WeakMap(), _setup = new WeakMap(), _a);
var focusManager = new FocusManager();

// node_modules/@tanstack/query-core/build/modern/onlineManager.js
var _online, _cleanup2, _setup2, _a2;
var OnlineManager = (_a2 = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _online, true);
    __privateAdd(this, _cleanup2);
    __privateAdd(this, _setup2);
    __privateSet(this, _setup2, (onOnline) => {
      if (!isServer && window.addEventListener) {
        const onlineListener = () => onOnline(true);
        const offlineListener = () => onOnline(false);
        window.addEventListener("online", onlineListener, false);
        window.addEventListener("offline", offlineListener, false);
        return () => {
          window.removeEventListener("online", onlineListener);
          window.removeEventListener("offline", offlineListener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup2)) {
      this.setEventListener(__privateGet(this, _setup2));
    }
  }
  onUnsubscribe() {
    var _a11;
    if (!this.hasListeners()) {
      (_a11 = __privateGet(this, _cleanup2)) == null ? void 0 : _a11.call(this);
      __privateSet(this, _cleanup2, void 0);
    }
  }
  setEventListener(setup) {
    var _a11;
    __privateSet(this, _setup2, setup);
    (_a11 = __privateGet(this, _cleanup2)) == null ? void 0 : _a11.call(this);
    __privateSet(this, _cleanup2, setup(this.setOnline.bind(this)));
  }
  setOnline(online) {
    const changed = __privateGet(this, _online) !== online;
    if (changed) {
      __privateSet(this, _online, online);
      this.listeners.forEach((listener) => {
        listener(online);
      });
    }
  }
  isOnline() {
    return __privateGet(this, _online);
  }
}, _online = new WeakMap(), _cleanup2 = new WeakMap(), _setup2 = new WeakMap(), _a2);
var onlineManager = new OnlineManager();

// node_modules/@tanstack/query-core/build/modern/thenable.js
function pendingThenable() {
  let resolve;
  let reject;
  const thenable = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  thenable.status = "pending";
  thenable.catch(() => {
  });
  function finalize(data) {
    Object.assign(thenable, data);
    delete thenable.resolve;
    delete thenable.reject;
  }
  thenable.resolve = (value) => {
    finalize({
      status: "fulfilled",
      value
    });
    resolve(value);
  };
  thenable.reject = (reason) => {
    finalize({
      status: "rejected",
      reason
    });
    reject(reason);
  };
  return thenable;
}

// node_modules/@tanstack/query-core/build/modern/retryer.js
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode ?? "online") === "online" ? onlineManager.isOnline() : true;
}
var CancelledError = class extends Error {
  constructor(options) {
    super("CancelledError");
    this.revert = options == null ? void 0 : options.revert;
    this.silent = options == null ? void 0 : options.silent;
  }
};
function isCancelledError(value) {
  return value instanceof CancelledError;
}
function createRetryer(config) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let isResolved = false;
  let continueFn;
  const thenable = pendingThenable();
  const cancel = (cancelOptions) => {
    var _a11;
    if (!isResolved) {
      reject(new CancelledError(cancelOptions));
      (_a11 = config.abort) == null ? void 0 : _a11.call(config);
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const canContinue = () => focusManager.isFocused() && (config.networkMode === "always" || onlineManager.isOnline()) && config.canRun();
  const canStart = () => canFetch(config.networkMode) && config.canRun();
  const resolve = (value) => {
    var _a11;
    if (!isResolved) {
      isResolved = true;
      (_a11 = config.onSuccess) == null ? void 0 : _a11.call(config, value);
      continueFn == null ? void 0 : continueFn();
      thenable.resolve(value);
    }
  };
  const reject = (value) => {
    var _a11;
    if (!isResolved) {
      isResolved = true;
      (_a11 = config.onError) == null ? void 0 : _a11.call(config, value);
      continueFn == null ? void 0 : continueFn();
      thenable.reject(value);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      var _a11;
      continueFn = (value) => {
        if (isResolved || canContinue()) {
          continueResolve(value);
        }
      };
      (_a11 = config.onPause) == null ? void 0 : _a11.call(config);
    }).then(() => {
      var _a11;
      continueFn = void 0;
      if (!isResolved) {
        (_a11 = config.onContinue) == null ? void 0 : _a11.call(config);
      }
    });
  };
  const run = () => {
    if (isResolved) {
      return;
    }
    let promiseOrValue;
    const initialPromise = failureCount === 0 ? config.initialPromise : void 0;
    try {
      promiseOrValue = initialPromise ?? config.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      var _a11;
      if (isResolved) {
        return;
      }
      const retry = config.retry ?? (isServer ? 0 : 3);
      const retryDelay = config.retryDelay ?? defaultRetryDelay;
      const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
      if (isRetryCancelled || !shouldRetry) {
        reject(error);
        return;
      }
      failureCount++;
      (_a11 = config.onFail) == null ? void 0 : _a11.call(config, failureCount, error);
      sleep(delay).then(() => {
        return canContinue() ? void 0 : pause();
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run();
        }
      });
    });
  };
  return {
    promise: thenable,
    cancel,
    continue: () => {
      continueFn == null ? void 0 : continueFn();
      return thenable;
    },
    cancelRetry,
    continueRetry,
    canStart,
    start: () => {
      if (canStart()) {
        run();
      } else {
        pause().then(run);
      }
      return thenable;
    }
  };
}

// node_modules/@tanstack/query-core/build/modern/notifyManager.js
function createNotifyManager() {
  let queue = [];
  let transactions = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  let scheduleFn = (cb) => setTimeout(cb, 0);
  const schedule = (callback) => {
    if (transactions) {
      queue.push(callback);
    } else {
      scheduleFn(() => {
        notifyFn(callback);
      });
    }
  };
  const flush = () => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleFn(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  return {
    batch: (callback) => {
      let result;
      transactions++;
      try {
        result = callback();
      } finally {
        transactions--;
        if (!transactions) {
          flush();
        }
      }
      return result;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (callback) => {
      return (...args) => {
        schedule(() => {
          callback(...args);
        });
      };
    },
    schedule,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (fn) => {
      notifyFn = fn;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (fn) => {
      batchNotifyFn = fn;
    },
    setScheduler: (fn) => {
      scheduleFn = fn;
    }
  };
}
var notifyManager = createNotifyManager();

// node_modules/@tanstack/query-core/build/modern/removable.js
var _gcTimeout, _a3;
var Removable = (_a3 = class {
  constructor() {
    __privateAdd(this, _gcTimeout);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout();
    if (isValidTimeout(this.gcTime)) {
      __privateSet(this, _gcTimeout, setTimeout(() => {
        this.optionalRemove();
      }, this.gcTime));
    }
  }
  updateGcTime(newGcTime) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    if (__privateGet(this, _gcTimeout)) {
      clearTimeout(__privateGet(this, _gcTimeout));
      __privateSet(this, _gcTimeout, void 0);
    }
  }
}, _gcTimeout = new WeakMap(), _a3);

// node_modules/@tanstack/query-core/build/modern/query.js
var _initialState, _revertState, _cache, _retryer, _defaultOptions, _abortSignalConsumed, _Query_instances, dispatch_fn, _a4;
var Query = (_a4 = class extends Removable {
  constructor(config) {
    super();
    __privateAdd(this, _Query_instances);
    __privateAdd(this, _initialState);
    __privateAdd(this, _revertState);
    __privateAdd(this, _cache);
    __privateAdd(this, _retryer);
    __privateAdd(this, _defaultOptions);
    __privateAdd(this, _abortSignalConsumed);
    __privateSet(this, _abortSignalConsumed, false);
    __privateSet(this, _defaultOptions, config.defaultOptions);
    this.setOptions(config.options);
    this.observers = [];
    __privateSet(this, _cache, config.cache);
    this.queryKey = config.queryKey;
    this.queryHash = config.queryHash;
    __privateSet(this, _initialState, getDefaultState(this.options));
    this.state = config.state ?? __privateGet(this, _initialState);
    this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var _a11;
    return (_a11 = __privateGet(this, _retryer)) == null ? void 0 : _a11.promise;
  }
  setOptions(options) {
    this.options = { ...__privateGet(this, _defaultOptions), ...options };
    this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === "idle") {
      __privateGet(this, _cache).remove(this);
    }
  }
  setData(newData, options) {
    const data = replaceData(this.state.data, newData, this.options);
    __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
      data,
      type: "success",
      dataUpdatedAt: options == null ? void 0 : options.updatedAt,
      manual: options == null ? void 0 : options.manual
    });
    return data;
  }
  setState(state, setStateOptions) {
    __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "setState", state, setStateOptions });
  }
  cancel(options) {
    var _a11, _b;
    const promise = (_a11 = __privateGet(this, _retryer)) == null ? void 0 : _a11.promise;
    (_b = __privateGet(this, _retryer)) == null ? void 0 : _b.cancel(options);
    return promise ? promise.then(noop).catch(noop) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({ silent: true });
  }
  reset() {
    this.destroy();
    this.setState(__privateGet(this, _initialState));
  }
  isActive() {
    return this.observers.some(
      (observer) => resolveEnabled(observer.options.enabled, this) !== false
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive();
  }
  isStale() {
    if (this.state.isInvalidated) {
      return true;
    }
    if (this.getObserversCount() > 0) {
      return this.observers.some(
        (observer) => observer.getCurrentResult().isStale
      );
    }
    return this.state.data === void 0;
  }
  isStaleByTime(staleTime = 0) {
    return this.state.isInvalidated || this.state.data === void 0 || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    var _a11;
    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());
    observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
    (_a11 = __privateGet(this, _retryer)) == null ? void 0 : _a11.continue();
  }
  onOnline() {
    var _a11;
    const observer = this.observers.find((x) => x.shouldFetchOnReconnect());
    observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
    (_a11 = __privateGet(this, _retryer)) == null ? void 0 : _a11.continue();
  }
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
      this.clearGcTimeout();
      __privateGet(this, _cache).notify({ type: "observerAdded", query: this, observer });
    }
  }
  removeObserver(observer) {
    if (this.observers.includes(observer)) {
      this.observers = this.observers.filter((x) => x !== observer);
      if (!this.observers.length) {
        if (__privateGet(this, _retryer)) {
          if (__privateGet(this, _abortSignalConsumed)) {
            __privateGet(this, _retryer).cancel({ revert: true });
          } else {
            __privateGet(this, _retryer).cancelRetry();
          }
        }
        this.scheduleGc();
      }
      __privateGet(this, _cache).notify({ type: "observerRemoved", query: this, observer });
    }
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "invalidate" });
    }
  }
  fetch(options, fetchOptions) {
    var _a11, _b, _c;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && (fetchOptions == null ? void 0 : fetchOptions.cancelRefetch)) {
        this.cancel({ silent: true });
      } else if (__privateGet(this, _retryer)) {
        __privateGet(this, _retryer).continueRetry();
        return __privateGet(this, _retryer).promise;
      }
    }
    if (options) {
      this.setOptions(options);
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x) => x.options.queryFn);
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    if (true) {
      if (!Array.isArray(this.options.queryKey)) {
        console.error(
          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`
        );
      }
    }
    const abortController = new AbortController();
    const addSignalProperty = (object) => {
      Object.defineProperty(object, "signal", {
        enumerable: true,
        get: () => {
          __privateSet(this, _abortSignalConsumed, true);
          return abortController.signal;
        }
      });
    };
    const fetchFn = () => {
      const queryFn = ensureQueryFn(this.options, fetchOptions);
      const queryFnContext = {
        queryKey: this.queryKey,
        meta: this.meta
      };
      addSignalProperty(queryFnContext);
      __privateSet(this, _abortSignalConsumed, false);
      if (this.options.persister) {
        return this.options.persister(
          queryFn,
          queryFnContext,
          this
        );
      }
      return queryFn(queryFnContext);
    };
    const context = {
      fetchOptions,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn
    };
    addSignalProperty(context);
    (_a11 = this.options.behavior) == null ? void 0 : _a11.onFetch(
      context,
      this
    );
    __privateSet(this, _revertState, this.state);
    if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_b = context.fetchOptions) == null ? void 0 : _b.meta)) {
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "fetch", meta: (_c = context.fetchOptions) == null ? void 0 : _c.meta });
    }
    const onError = (error) => {
      var _a12, _b2, _c2, _d;
      if (!(isCancelledError(error) && error.silent)) {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
          type: "error",
          error
        });
      }
      if (!isCancelledError(error)) {
        (_b2 = (_a12 = __privateGet(this, _cache).config).onError) == null ? void 0 : _b2.call(
          _a12,
          error,
          this
        );
        (_d = (_c2 = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _d.call(
          _c2,
          this.state.data,
          error,
          this
        );
      }
      if (!this.isFetchingOptimistic) {
        this.scheduleGc();
      }
      this.isFetchingOptimistic = false;
    };
    __privateSet(this, _retryer, createRetryer({
      initialPromise: fetchOptions == null ? void 0 : fetchOptions.initialPromise,
      fn: context.fetchFn,
      abort: abortController.abort.bind(abortController),
      onSuccess: (data) => {
        var _a12, _b2, _c2, _d;
        if (data === void 0) {
          if (true) {
            console.error(
              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
            );
          }
          onError(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(data);
        } catch (error) {
          onError(error);
          return;
        }
        (_b2 = (_a12 = __privateGet(this, _cache).config).onSuccess) == null ? void 0 : _b2.call(_a12, data, this);
        (_d = (_c2 = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _d.call(
          _c2,
          data,
          this.state.error,
          this
        );
        if (!this.isFetchingOptimistic) {
          this.scheduleGc();
        }
        this.isFetchingOptimistic = false;
      },
      onError,
      onFail: (failureCount, error) => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "failed", failureCount, error });
      },
      onPause: () => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "pause" });
      },
      onContinue: () => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "continue" });
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay,
      networkMode: context.options.networkMode,
      canRun: () => true
    }));
    return __privateGet(this, _retryer).start();
  }
}, _initialState = new WeakMap(), _revertState = new WeakMap(), _cache = new WeakMap(), _retryer = new WeakMap(), _defaultOptions = new WeakMap(), _abortSignalConsumed = new WeakMap(), _Query_instances = new WeakSet(), dispatch_fn = function(action) {
  const reducer = (state) => {
    switch (action.type) {
      case "failed":
        return {
          ...state,
          fetchFailureCount: action.failureCount,
          fetchFailureReason: action.error
        };
      case "pause":
        return {
          ...state,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...state,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...state,
          ...fetchState(state.data, this.options),
          fetchMeta: action.meta ?? null
        };
      case "success":
        return {
          ...state,
          data: action.data,
          dataUpdateCount: state.dataUpdateCount + 1,
          dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: false,
          status: "success",
          ...!action.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const error = action.error;
        if (isCancelledError(error) && error.revert && __privateGet(this, _revertState)) {
          return { ...__privateGet(this, _revertState), fetchStatus: "idle" };
        }
        return {
          ...state,
          error,
          errorUpdateCount: state.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: state.fetchFailureCount + 1,
          fetchFailureReason: error,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...state,
          isInvalidated: true
        };
      case "setState":
        return {
          ...state,
          ...action.state
        };
    }
  };
  this.state = reducer(this.state);
  notifyManager.batch(() => {
    this.observers.forEach((observer) => {
      observer.onQueryUpdate();
    });
    __privateGet(this, _cache).notify({ query: this, type: "updated", action });
  });
}, _a4);
function fetchState(data, options) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: canFetch(options.networkMode) ? "fetching" : "paused",
    ...data === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function getDefaultState(options) {
  const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
  const hasData = data !== void 0;
  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  return {
    data,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "pending",
    fetchStatus: "idle"
  };
}

// node_modules/@tanstack/query-core/build/modern/queryCache.js
var _queries, _a5;
var QueryCache = (_a5 = class extends Subscribable {
  constructor(config = {}) {
    super();
    __privateAdd(this, _queries);
    this.config = config;
    __privateSet(this, _queries, /* @__PURE__ */ new Map());
  }
  build(client, options, state) {
    const queryKey = options.queryKey;
    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);
    let query = this.get(queryHash);
    if (!query) {
      query = new Query({
        cache: this,
        queryKey,
        queryHash,
        options: client.defaultQueryOptions(options),
        state,
        defaultOptions: client.getQueryDefaults(queryKey)
      });
      this.add(query);
    }
    return query;
  }
  add(query) {
    if (!__privateGet(this, _queries).has(query.queryHash)) {
      __privateGet(this, _queries).set(query.queryHash, query);
      this.notify({
        type: "added",
        query
      });
    }
  }
  remove(query) {
    const queryInMap = __privateGet(this, _queries).get(query.queryHash);
    if (queryInMap) {
      query.destroy();
      if (queryInMap === query) {
        __privateGet(this, _queries).delete(query.queryHash);
      }
      this.notify({ type: "removed", query });
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        this.remove(query);
      });
    });
  }
  get(queryHash) {
    return __privateGet(this, _queries).get(queryHash);
  }
  getAll() {
    return [...__privateGet(this, _queries).values()];
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (query) => matchQuery(defaultedFilters, query)
    );
  }
  findAll(filters = {}) {
    const queries = this.getAll();
    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  onFocus() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onFocus();
      });
    });
  }
  onOnline() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onOnline();
      });
    });
  }
}, _queries = new WeakMap(), _a5);

// node_modules/@tanstack/query-core/build/modern/mutation.js
var _observers, _mutationCache, _retryer2, _Mutation_instances, dispatch_fn2, _a6;
var Mutation = (_a6 = class extends Removable {
  constructor(config) {
    super();
    __privateAdd(this, _Mutation_instances);
    __privateAdd(this, _observers);
    __privateAdd(this, _mutationCache);
    __privateAdd(this, _retryer2);
    this.mutationId = config.mutationId;
    __privateSet(this, _mutationCache, config.mutationCache);
    __privateSet(this, _observers, []);
    this.state = config.state || getDefaultState2();
    this.setOptions(config.options);
    this.scheduleGc();
  }
  setOptions(options) {
    this.options = options;
    this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(observer) {
    if (!__privateGet(this, _observers).includes(observer)) {
      __privateGet(this, _observers).push(observer);
      this.clearGcTimeout();
      __privateGet(this, _mutationCache).notify({
        type: "observerAdded",
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    __privateSet(this, _observers, __privateGet(this, _observers).filter((x) => x !== observer));
    this.scheduleGc();
    __privateGet(this, _mutationCache).notify({
      type: "observerRemoved",
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!__privateGet(this, _observers).length) {
      if (this.state.status === "pending") {
        this.scheduleGc();
      } else {
        __privateGet(this, _mutationCache).remove(this);
      }
    }
  }
  continue() {
    var _a11;
    return ((_a11 = __privateGet(this, _retryer2)) == null ? void 0 : _a11.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(variables) {
    var _a11, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t;
    __privateSet(this, _retryer2, createRetryer({
      fn: () => {
        if (!this.options.mutationFn) {
          return Promise.reject(new Error("No mutationFn found"));
        }
        return this.options.mutationFn(variables);
      },
      onFail: (failureCount, error) => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "failed", failureCount, error });
      },
      onPause: () => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "pause" });
      },
      onContinue: () => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "continue" });
      },
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => __privateGet(this, _mutationCache).canRun(this)
    }));
    const restored = this.state.status === "pending";
    const isPaused = !__privateGet(this, _retryer2).canStart();
    try {
      if (!restored) {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "pending", variables, isPaused });
        await ((_b = (_a11 = __privateGet(this, _mutationCache).config).onMutate) == null ? void 0 : _b.call(
          _a11,
          variables,
          this
        ));
        const context = await ((_d = (_c = this.options).onMutate) == null ? void 0 : _d.call(_c, variables));
        if (context !== this.state.context) {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, {
            type: "pending",
            context,
            variables,
            isPaused
          });
        }
      }
      const data = await __privateGet(this, _retryer2).start();
      await ((_f = (_e = __privateGet(this, _mutationCache).config).onSuccess) == null ? void 0 : _f.call(
        _e,
        data,
        variables,
        this.state.context,
        this
      ));
      await ((_h = (_g = this.options).onSuccess) == null ? void 0 : _h.call(_g, data, variables, this.state.context));
      await ((_j = (_i = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _j.call(
        _i,
        data,
        null,
        this.state.variables,
        this.state.context,
        this
      ));
      await ((_l = (_k = this.options).onSettled) == null ? void 0 : _l.call(_k, data, null, variables, this.state.context));
      __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "success", data });
      return data;
    } catch (error) {
      try {
        await ((_n = (_m = __privateGet(this, _mutationCache).config).onError) == null ? void 0 : _n.call(
          _m,
          error,
          variables,
          this.state.context,
          this
        ));
        await ((_p = (_o = this.options).onError) == null ? void 0 : _p.call(
          _o,
          error,
          variables,
          this.state.context
        ));
        await ((_r = (_q = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _r.call(
          _q,
          void 0,
          error,
          this.state.variables,
          this.state.context,
          this
        ));
        await ((_t = (_s = this.options).onSettled) == null ? void 0 : _t.call(
          _s,
          void 0,
          error,
          variables,
          this.state.context
        ));
        throw error;
      } finally {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "error", error });
      }
    } finally {
      __privateGet(this, _mutationCache).runNext(this);
    }
  }
}, _observers = new WeakMap(), _mutationCache = new WeakMap(), _retryer2 = new WeakMap(), _Mutation_instances = new WeakSet(), dispatch_fn2 = function(action) {
  const reducer = (state) => {
    switch (action.type) {
      case "failed":
        return {
          ...state,
          failureCount: action.failureCount,
          failureReason: action.error
        };
      case "pause":
        return {
          ...state,
          isPaused: true
        };
      case "continue":
        return {
          ...state,
          isPaused: false
        };
      case "pending":
        return {
          ...state,
          context: action.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: action.isPaused,
          status: "pending",
          variables: action.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...state,
          data: action.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: false
        };
      case "error":
        return {
          ...state,
          data: void 0,
          error: action.error,
          failureCount: state.failureCount + 1,
          failureReason: action.error,
          isPaused: false,
          status: "error"
        };
    }
  };
  this.state = reducer(this.state);
  notifyManager.batch(() => {
    __privateGet(this, _observers).forEach((observer) => {
      observer.onMutationUpdate(action);
    });
    __privateGet(this, _mutationCache).notify({
      mutation: this,
      type: "updated",
      action
    });
  });
}, _a6);
function getDefaultState2() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}

// node_modules/@tanstack/query-core/build/modern/mutationCache.js
var _mutations, _mutationId, _a7;
var MutationCache = (_a7 = class extends Subscribable {
  constructor(config = {}) {
    super();
    __privateAdd(this, _mutations);
    __privateAdd(this, _mutationId);
    this.config = config;
    __privateSet(this, _mutations, /* @__PURE__ */ new Map());
    __privateSet(this, _mutationId, Date.now());
  }
  build(client, options, state) {
    const mutation = new Mutation({
      mutationCache: this,
      mutationId: ++__privateWrapper(this, _mutationId)._,
      options: client.defaultMutationOptions(options),
      state
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    const scope = scopeFor(mutation);
    const mutations = __privateGet(this, _mutations).get(scope) ?? [];
    mutations.push(mutation);
    __privateGet(this, _mutations).set(scope, mutations);
    this.notify({ type: "added", mutation });
  }
  remove(mutation) {
    var _a11;
    const scope = scopeFor(mutation);
    if (__privateGet(this, _mutations).has(scope)) {
      const mutations = (_a11 = __privateGet(this, _mutations).get(scope)) == null ? void 0 : _a11.filter((x) => x !== mutation);
      if (mutations) {
        if (mutations.length === 0) {
          __privateGet(this, _mutations).delete(scope);
        } else {
          __privateGet(this, _mutations).set(scope, mutations);
        }
      }
    }
    this.notify({ type: "removed", mutation });
  }
  canRun(mutation) {
    var _a11;
    const firstPendingMutation = (_a11 = __privateGet(this, _mutations).get(scopeFor(mutation))) == null ? void 0 : _a11.find((m) => m.state.status === "pending");
    return !firstPendingMutation || firstPendingMutation === mutation;
  }
  runNext(mutation) {
    var _a11;
    const foundMutation = (_a11 = __privateGet(this, _mutations).get(scopeFor(mutation))) == null ? void 0 : _a11.find((m) => m !== mutation && m.state.isPaused);
    return (foundMutation == null ? void 0 : foundMutation.continue()) ?? Promise.resolve();
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((mutation) => {
        this.remove(mutation);
      });
    });
  }
  getAll() {
    return [...__privateGet(this, _mutations).values()].flat();
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (mutation) => matchMutation(defaultedFilters, mutation)
    );
  }
  findAll(filters = {}) {
    return this.getAll().filter((mutation) => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    const pausedMutations = this.getAll().filter((x) => x.state.isPaused);
    return notifyManager.batch(
      () => Promise.all(
        pausedMutations.map((mutation) => mutation.continue().catch(noop))
      )
    );
  }
}, _mutations = new WeakMap(), _mutationId = new WeakMap(), _a7);
function scopeFor(mutation) {
  var _a11;
  return ((_a11 = mutation.options.scope) == null ? void 0 : _a11.id) ?? String(mutation.mutationId);
}

// node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js
function infiniteQueryBehavior(pages) {
  return {
    onFetch: (context, query) => {
      var _a11, _b, _c, _d, _e;
      const options = context.options;
      const direction = (_c = (_b = (_a11 = context.fetchOptions) == null ? void 0 : _a11.meta) == null ? void 0 : _b.fetchMore) == null ? void 0 : _c.direction;
      const oldPages = ((_d = context.state.data) == null ? void 0 : _d.pages) || [];
      const oldPageParams = ((_e = context.state.data) == null ? void 0 : _e.pageParams) || [];
      let result = { pages: [], pageParams: [] };
      let currentPage = 0;
      const fetchFn = async () => {
        let cancelled = false;
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              if (context.signal.aborted) {
                cancelled = true;
              } else {
                context.signal.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context.signal;
            }
          });
        };
        const queryFn = ensureQueryFn(context.options, context.fetchOptions);
        const fetchPage = async (data, param, previous) => {
          if (cancelled) {
            return Promise.reject();
          }
          if (param == null && data.pages.length) {
            return Promise.resolve(data);
          }
          const queryFnContext = {
            queryKey: context.queryKey,
            pageParam: param,
            direction: previous ? "backward" : "forward",
            meta: context.options.meta
          };
          addSignalProperty(queryFnContext);
          const page = await queryFn(
            queryFnContext
          );
          const { maxPages } = context.options;
          const addTo = previous ? addToStart : addToEnd;
          return {
            pages: addTo(data.pages, page, maxPages),
            pageParams: addTo(data.pageParams, param, maxPages)
          };
        };
        if (direction && oldPages.length) {
          const previous = direction === "backward";
          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
          const oldData = {
            pages: oldPages,
            pageParams: oldPageParams
          };
          const param = pageParamFn(options, oldData);
          result = await fetchPage(oldData, param, previous);
        } else {
          const remainingPages = pages ?? oldPages.length;
          do {
            const param = currentPage === 0 ? oldPageParams[0] ?? options.initialPageParam : getNextPageParam(options, result);
            if (currentPage > 0 && param == null) {
              break;
            }
            result = await fetchPage(result, param);
            currentPage++;
          } while (currentPage < remainingPages);
        }
        return result;
      };
      if (context.options.persister) {
        context.fetchFn = () => {
          var _a12, _b2;
          return (_b2 = (_a12 = context.options).persister) == null ? void 0 : _b2.call(
            _a12,
            fetchFn,
            {
              queryKey: context.queryKey,
              meta: context.options.meta,
              signal: context.signal
            },
            query
          );
        };
      } else {
        context.fetchFn = fetchFn;
      }
    }
  };
}
function getNextPageParam(options, { pages, pageParams }) {
  const lastIndex = pages.length - 1;
  return pages.length > 0 ? options.getNextPageParam(
    pages[lastIndex],
    pages,
    pageParams[lastIndex],
    pageParams
  ) : void 0;
}
function getPreviousPageParam(options, { pages, pageParams }) {
  var _a11;
  return pages.length > 0 ? (_a11 = options.getPreviousPageParam) == null ? void 0 : _a11.call(options, pages[0], pages, pageParams[0], pageParams) : void 0;
}
function hasNextPage(options, data) {
  if (!data)
    return false;
  return getNextPageParam(options, data) != null;
}
function hasPreviousPage(options, data) {
  if (!data || !options.getPreviousPageParam)
    return false;
  return getPreviousPageParam(options, data) != null;
}

// node_modules/@tanstack/query-core/build/modern/queryClient.js
var _queryCache, _mutationCache2, _defaultOptions2, _queryDefaults, _mutationDefaults, _mountCount, _unsubscribeFocus, _unsubscribeOnline, _a8;
var QueryClient = (_a8 = class {
  constructor(config = {}) {
    __privateAdd(this, _queryCache);
    __privateAdd(this, _mutationCache2);
    __privateAdd(this, _defaultOptions2);
    __privateAdd(this, _queryDefaults);
    __privateAdd(this, _mutationDefaults);
    __privateAdd(this, _mountCount);
    __privateAdd(this, _unsubscribeFocus);
    __privateAdd(this, _unsubscribeOnline);
    __privateSet(this, _queryCache, config.queryCache || new QueryCache());
    __privateSet(this, _mutationCache2, config.mutationCache || new MutationCache());
    __privateSet(this, _defaultOptions2, config.defaultOptions || {});
    __privateSet(this, _queryDefaults, /* @__PURE__ */ new Map());
    __privateSet(this, _mutationDefaults, /* @__PURE__ */ new Map());
    __privateSet(this, _mountCount, 0);
  }
  mount() {
    __privateWrapper(this, _mountCount)._++;
    if (__privateGet(this, _mountCount) !== 1)
      return;
    __privateSet(this, _unsubscribeFocus, focusManager.subscribe(async (focused) => {
      if (focused) {
        await this.resumePausedMutations();
        __privateGet(this, _queryCache).onFocus();
      }
    }));
    __privateSet(this, _unsubscribeOnline, onlineManager.subscribe(async (online) => {
      if (online) {
        await this.resumePausedMutations();
        __privateGet(this, _queryCache).onOnline();
      }
    }));
  }
  unmount() {
    var _a11, _b;
    __privateWrapper(this, _mountCount)._--;
    if (__privateGet(this, _mountCount) !== 0)
      return;
    (_a11 = __privateGet(this, _unsubscribeFocus)) == null ? void 0 : _a11.call(this);
    __privateSet(this, _unsubscribeFocus, void 0);
    (_b = __privateGet(this, _unsubscribeOnline)) == null ? void 0 : _b.call(this);
    __privateSet(this, _unsubscribeOnline, void 0);
  }
  isFetching(filters) {
    return __privateGet(this, _queryCache).findAll({ ...filters, fetchStatus: "fetching" }).length;
  }
  isMutating(filters) {
    return __privateGet(this, _mutationCache2).findAll({ ...filters, status: "pending" }).length;
  }
  getQueryData(queryKey) {
    var _a11;
    const options = this.defaultQueryOptions({ queryKey });
    return (_a11 = __privateGet(this, _queryCache).get(options.queryHash)) == null ? void 0 : _a11.state.data;
  }
  ensureQueryData(options) {
    const cachedData = this.getQueryData(options.queryKey);
    if (cachedData === void 0)
      return this.fetchQuery(options);
    else {
      const defaultedOptions = this.defaultQueryOptions(options);
      const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
      if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {
        void this.prefetchQuery(defaultedOptions);
      }
      return Promise.resolve(cachedData);
    }
  }
  getQueriesData(filters) {
    return __privateGet(this, _queryCache).findAll(filters).map(({ queryKey, state }) => {
      const data = state.data;
      return [queryKey, data];
    });
  }
  setQueryData(queryKey, updater, options) {
    const defaultedOptions = this.defaultQueryOptions({ queryKey });
    const query = __privateGet(this, _queryCache).get(
      defaultedOptions.queryHash
    );
    const prevData = query == null ? void 0 : query.state.data;
    const data = functionalUpdate(updater, prevData);
    if (data === void 0) {
      return void 0;
    }
    return __privateGet(this, _queryCache).build(this, defaultedOptions).setData(data, { ...options, manual: true });
  }
  setQueriesData(filters, updater, options) {
    return notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).map(({ queryKey }) => [
        queryKey,
        this.setQueryData(queryKey, updater, options)
      ])
    );
  }
  getQueryState(queryKey) {
    var _a11;
    const options = this.defaultQueryOptions({ queryKey });
    return (_a11 = __privateGet(this, _queryCache).get(options.queryHash)) == null ? void 0 : _a11.state;
  }
  removeQueries(filters) {
    const queryCache = __privateGet(this, _queryCache);
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(filters, options) {
    const queryCache = __privateGet(this, _queryCache);
    const refetchFilters = {
      type: "active",
      ...filters
    };
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset();
      });
      return this.refetchQueries(refetchFilters, options);
    });
  }
  cancelQueries(filters = {}, cancelOptions = {}) {
    const defaultedCancelOptions = { revert: true, ...cancelOptions };
    const promises = notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).map((query) => query.cancel(defaultedCancelOptions))
    );
    return Promise.all(promises).then(noop).catch(noop);
  }
  invalidateQueries(filters = {}, options = {}) {
    return notifyManager.batch(() => {
      __privateGet(this, _queryCache).findAll(filters).forEach((query) => {
        query.invalidate();
      });
      if (filters.refetchType === "none") {
        return Promise.resolve();
      }
      const refetchFilters = {
        ...filters,
        type: filters.refetchType ?? filters.type ?? "active"
      };
      return this.refetchQueries(refetchFilters, options);
    });
  }
  refetchQueries(filters = {}, options) {
    const fetchOptions = {
      ...options,
      cancelRefetch: (options == null ? void 0 : options.cancelRefetch) ?? true
    };
    const promises = notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
        let promise = query.fetch(void 0, fetchOptions);
        if (!fetchOptions.throwOnError) {
          promise = promise.catch(noop);
        }
        return query.state.fetchStatus === "paused" ? Promise.resolve() : promise;
      })
    );
    return Promise.all(promises).then(noop);
  }
  fetchQuery(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    if (defaultedOptions.retry === void 0) {
      defaultedOptions.retry = false;
    }
    const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
    return query.isStaleByTime(
      resolveStaleTime(defaultedOptions.staleTime, query)
    ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(options) {
    return this.fetchQuery(options).then(noop).catch(noop);
  }
  fetchInfiniteQuery(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.fetchQuery(options);
  }
  prefetchInfiniteQuery(options) {
    return this.fetchInfiniteQuery(options).then(noop).catch(noop);
  }
  ensureInfiniteQueryData(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.ensureQueryData(options);
  }
  resumePausedMutations() {
    if (onlineManager.isOnline()) {
      return __privateGet(this, _mutationCache2).resumePausedMutations();
    }
    return Promise.resolve();
  }
  getQueryCache() {
    return __privateGet(this, _queryCache);
  }
  getMutationCache() {
    return __privateGet(this, _mutationCache2);
  }
  getDefaultOptions() {
    return __privateGet(this, _defaultOptions2);
  }
  setDefaultOptions(options) {
    __privateSet(this, _defaultOptions2, options);
  }
  setQueryDefaults(queryKey, options) {
    __privateGet(this, _queryDefaults).set(hashKey(queryKey), {
      queryKey,
      defaultOptions: options
    });
  }
  getQueryDefaults(queryKey) {
    const defaults = [...__privateGet(this, _queryDefaults).values()];
    let result = {};
    defaults.forEach((queryDefault) => {
      if (partialMatchKey(queryKey, queryDefault.queryKey)) {
        result = { ...result, ...queryDefault.defaultOptions };
      }
    });
    return result;
  }
  setMutationDefaults(mutationKey, options) {
    __privateGet(this, _mutationDefaults).set(hashKey(mutationKey), {
      mutationKey,
      defaultOptions: options
    });
  }
  getMutationDefaults(mutationKey) {
    const defaults = [...__privateGet(this, _mutationDefaults).values()];
    let result = {};
    defaults.forEach((queryDefault) => {
      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
        result = { ...result, ...queryDefault.defaultOptions };
      }
    });
    return result;
  }
  defaultQueryOptions(options) {
    if (options._defaulted) {
      return options;
    }
    const defaultedOptions = {
      ...__privateGet(this, _defaultOptions2).queries,
      ...this.getQueryDefaults(options.queryKey),
      ...options,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(
        defaultedOptions.queryKey,
        defaultedOptions
      );
    }
    if (defaultedOptions.refetchOnReconnect === void 0) {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
    }
    if (defaultedOptions.throwOnError === void 0) {
      defaultedOptions.throwOnError = !!defaultedOptions.suspense;
    }
    if (!defaultedOptions.networkMode && defaultedOptions.persister) {
      defaultedOptions.networkMode = "offlineFirst";
    }
    if (defaultedOptions.enabled !== true && defaultedOptions.queryFn === skipToken) {
      defaultedOptions.enabled = false;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options) {
    if (options == null ? void 0 : options._defaulted) {
      return options;
    }
    return {
      ...__privateGet(this, _defaultOptions2).mutations,
      ...(options == null ? void 0 : options.mutationKey) && this.getMutationDefaults(options.mutationKey),
      ...options,
      _defaulted: true
    };
  }
  clear() {
    __privateGet(this, _queryCache).clear();
    __privateGet(this, _mutationCache2).clear();
  }
}, _queryCache = new WeakMap(), _mutationCache2 = new WeakMap(), _defaultOptions2 = new WeakMap(), _queryDefaults = new WeakMap(), _mutationDefaults = new WeakMap(), _mountCount = new WeakMap(), _unsubscribeFocus = new WeakMap(), _unsubscribeOnline = new WeakMap(), _a8);

// node_modules/@tanstack/query-core/build/modern/queryObserver.js
var _client, _currentQuery, _currentQueryInitialState, _currentResult, _currentResultState, _currentResultOptions, _currentThenable, _selectError, _selectFn, _selectResult, _lastQueryWithDefinedData, _staleTimeoutId, _refetchIntervalId, _currentRefetchInterval, _trackedProps, _QueryObserver_instances, executeFetch_fn, updateStaleTimeout_fn, computeRefetchInterval_fn, updateRefetchInterval_fn, updateTimers_fn, clearStaleTimeout_fn, clearRefetchInterval_fn, updateQuery_fn, notify_fn, _a9;
var QueryObserver = (_a9 = class extends Subscribable {
  constructor(client, options) {
    super();
    __privateAdd(this, _QueryObserver_instances);
    __privateAdd(this, _client);
    __privateAdd(this, _currentQuery);
    __privateAdd(this, _currentQueryInitialState);
    __privateAdd(this, _currentResult);
    __privateAdd(this, _currentResultState);
    __privateAdd(this, _currentResultOptions);
    __privateAdd(this, _currentThenable);
    __privateAdd(this, _selectError);
    __privateAdd(this, _selectFn);
    __privateAdd(this, _selectResult);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    __privateAdd(this, _lastQueryWithDefinedData);
    __privateAdd(this, _staleTimeoutId);
    __privateAdd(this, _refetchIntervalId);
    __privateAdd(this, _currentRefetchInterval);
    __privateAdd(this, _trackedProps, /* @__PURE__ */ new Set());
    this.options = options;
    __privateSet(this, _client, client);
    __privateSet(this, _selectError, null);
    __privateSet(this, _currentThenable, pendingThenable());
    if (!this.options.experimental_prefetchInRender) {
      __privateGet(this, _currentThenable).reject(
        new Error("experimental_prefetchInRender feature flag is not enabled")
      );
    }
    this.bindMethods();
    this.setOptions(options);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    if (this.listeners.size === 1) {
      __privateGet(this, _currentQuery).addObserver(this);
      if (shouldFetchOnMount(__privateGet(this, _currentQuery), this.options)) {
        __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
      } else {
        this.updateResult();
      }
      __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.destroy();
    }
  }
  shouldFetchOnReconnect() {
    return shouldFetchOn(
      __privateGet(this, _currentQuery),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return shouldFetchOn(
      __privateGet(this, _currentQuery),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set();
    __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);
    __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);
    __privateGet(this, _currentQuery).removeObserver(this);
  }
  setOptions(options, notifyOptions) {
    const prevOptions = this.options;
    const prevQuery = __privateGet(this, _currentQuery);
    this.options = __privateGet(this, _client).defaultQueryOptions(options);
    if (this.options.enabled !== void 0 && typeof this.options.enabled !== "boolean" && typeof this.options.enabled !== "function" && typeof resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== "boolean") {
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    }
    __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);
    __privateGet(this, _currentQuery).setOptions(this.options);
    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {
      __privateGet(this, _client).getQueryCache().notify({
        type: "observerOptionsUpdated",
        query: __privateGet(this, _currentQuery),
        observer: this
      });
    }
    const mounted = this.hasListeners();
    if (mounted && shouldFetchOptionally(
      __privateGet(this, _currentQuery),
      prevQuery,
      this.options,
      prevOptions
    )) {
      __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
    }
    this.updateResult(notifyOptions);
    if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || resolveStaleTime(this.options.staleTime, __privateGet(this, _currentQuery)) !== resolveStaleTime(prevOptions.staleTime, __privateGet(this, _currentQuery)))) {
      __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);
    }
    const nextRefetchInterval = __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this);
    if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || nextRefetchInterval !== __privateGet(this, _currentRefetchInterval))) {
      __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, nextRefetchInterval);
    }
  }
  getOptimisticResult(options) {
    const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), options);
    const result = this.createResult(query, options);
    if (shouldAssignObserverCurrentProperties(this, result)) {
      __privateSet(this, _currentResult, result);
      __privateSet(this, _currentResultOptions, this.options);
      __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);
    }
    return result;
  }
  getCurrentResult() {
    return __privateGet(this, _currentResult);
  }
  trackResult(result, onPropTracked) {
    const trackedResult = {};
    Object.keys(result).forEach((key) => {
      Object.defineProperty(trackedResult, key, {
        configurable: false,
        enumerable: true,
        get: () => {
          this.trackProp(key);
          onPropTracked == null ? void 0 : onPropTracked(key);
          return result[key];
        }
      });
    });
    return trackedResult;
  }
  trackProp(key) {
    __privateGet(this, _trackedProps).add(key);
  }
  getCurrentQuery() {
    return __privateGet(this, _currentQuery);
  }
  refetch({ ...options } = {}) {
    return this.fetch({
      ...options
    });
  }
  fetchOptimistic(options) {
    const defaultedOptions = __privateGet(this, _client).defaultQueryOptions(options);
    const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), defaultedOptions);
    query.isFetchingOptimistic = true;
    return query.fetch().then(() => this.createResult(query, defaultedOptions));
  }
  fetch(fetchOptions) {
    return __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this, {
      ...fetchOptions,
      cancelRefetch: fetchOptions.cancelRefetch ?? true
    }).then(() => {
      this.updateResult();
      return __privateGet(this, _currentResult);
    });
  }
  createResult(query, options) {
    var _a11;
    const prevQuery = __privateGet(this, _currentQuery);
    const prevOptions = this.options;
    const prevResult = __privateGet(this, _currentResult);
    const prevResultState = __privateGet(this, _currentResultState);
    const prevResultOptions = __privateGet(this, _currentResultOptions);
    const queryChange = query !== prevQuery;
    const queryInitialState = queryChange ? query.state : __privateGet(this, _currentQueryInitialState);
    const { state } = query;
    let newState = { ...state };
    let isPlaceholderData = false;
    let data;
    if (options._optimisticResults) {
      const mounted = this.hasListeners();
      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
      if (fetchOnMount || fetchOptionally) {
        newState = {
          ...newState,
          ...fetchState(state.data, query.options)
        };
      }
      if (options._optimisticResults === "isRestoring") {
        newState.fetchStatus = "idle";
      }
    }
    let { error, errorUpdatedAt, status } = newState;
    if (options.select && newState.data !== void 0) {
      if (prevResult && newState.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === __privateGet(this, _selectFn)) {
        data = __privateGet(this, _selectResult);
      } else {
        try {
          __privateSet(this, _selectFn, options.select);
          data = options.select(newState.data);
          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);
          __privateSet(this, _selectResult, data);
          __privateSet(this, _selectError, null);
        } catch (selectError) {
          __privateSet(this, _selectError, selectError);
        }
      }
    } else {
      data = newState.data;
    }
    if (options.placeholderData !== void 0 && data === void 0 && status === "pending") {
      let placeholderData;
      if ((prevResult == null ? void 0 : prevResult.isPlaceholderData) && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
        placeholderData = prevResult.data;
      } else {
        placeholderData = typeof options.placeholderData === "function" ? options.placeholderData(
          (_a11 = __privateGet(this, _lastQueryWithDefinedData)) == null ? void 0 : _a11.state.data,
          __privateGet(this, _lastQueryWithDefinedData)
        ) : options.placeholderData;
        if (options.select && placeholderData !== void 0) {
          try {
            placeholderData = options.select(placeholderData);
            __privateSet(this, _selectError, null);
          } catch (selectError) {
            __privateSet(this, _selectError, selectError);
          }
        }
      }
      if (placeholderData !== void 0) {
        status = "success";
        data = replaceData(
          prevResult == null ? void 0 : prevResult.data,
          placeholderData,
          options
        );
        isPlaceholderData = true;
      }
    }
    if (__privateGet(this, _selectError)) {
      error = __privateGet(this, _selectError);
      data = __privateGet(this, _selectResult);
      errorUpdatedAt = Date.now();
      status = "error";
    }
    const isFetching = newState.fetchStatus === "fetching";
    const isPending = status === "pending";
    const isError = status === "error";
    const isLoading = isPending && isFetching;
    const hasData = data !== void 0;
    const result = {
      status,
      fetchStatus: newState.fetchStatus,
      isPending,
      isSuccess: status === "success",
      isError,
      isInitialLoading: isLoading,
      isLoading,
      data,
      dataUpdatedAt: newState.dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount: newState.fetchFailureCount,
      failureReason: newState.fetchFailureReason,
      errorUpdateCount: newState.errorUpdateCount,
      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,
      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,
      isFetching,
      isRefetching: isFetching && !isPending,
      isLoadingError: isError && !hasData,
      isPaused: newState.fetchStatus === "paused",
      isPlaceholderData,
      isRefetchError: isError && hasData,
      isStale: isStale(query, options),
      refetch: this.refetch,
      promise: __privateGet(this, _currentThenable)
    };
    return result;
  }
  updateResult(notifyOptions) {
    const prevResult = __privateGet(this, _currentResult);
    const nextResult = this.createResult(__privateGet(this, _currentQuery), this.options);
    __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);
    __privateSet(this, _currentResultOptions, this.options);
    if (__privateGet(this, _currentResultState).data !== void 0) {
      __privateSet(this, _lastQueryWithDefinedData, __privateGet(this, _currentQuery));
    }
    if (shallowEqualObjects(nextResult, prevResult)) {
      return;
    }
    if (this.options.experimental_prefetchInRender) {
      const finalizeThenableIfPossible = (thenable) => {
        if (nextResult.status === "error") {
          thenable.reject(nextResult.error);
        } else if (nextResult.data !== void 0) {
          thenable.resolve(nextResult.data);
        }
      };
      const recreateThenable = () => {
        const pending = __privateSet(this, _currentThenable, nextResult.promise = pendingThenable());
        finalizeThenableIfPossible(pending);
      };
      const prevThenable = __privateGet(this, _currentThenable);
      switch (prevThenable.status) {
        case "pending":
          finalizeThenableIfPossible(prevThenable);
          break;
        case "fulfilled":
          if (nextResult.status === "error" || nextResult.data !== prevThenable.value) {
            recreateThenable();
          }
          break;
        case "rejected":
          if (nextResult.status !== "error" || nextResult.error !== prevThenable.reason) {
            recreateThenable();
          }
          break;
      }
    }
    __privateSet(this, _currentResult, nextResult);
    const defaultNotifyOptions = {};
    const shouldNotifyListeners = () => {
      if (!prevResult) {
        return true;
      }
      const { notifyOnChangeProps } = this.options;
      const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
      if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !__privateGet(this, _trackedProps).size) {
        return true;
      }
      const includedProps = new Set(
        notifyOnChangePropsValue ?? __privateGet(this, _trackedProps)
      );
      if (this.options.throwOnError) {
        includedProps.add("error");
      }
      return Object.keys(__privateGet(this, _currentResult)).some((key) => {
        const typedKey = key;
        const changed = __privateGet(this, _currentResult)[typedKey] !== prevResult[typedKey];
        return changed && includedProps.has(typedKey);
      });
    };
    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {
      defaultNotifyOptions.listeners = true;
    }
    __privateMethod(this, _QueryObserver_instances, notify_fn).call(this, { ...defaultNotifyOptions, ...notifyOptions });
  }
  onQueryUpdate() {
    this.updateResult();
    if (this.hasListeners()) {
      __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);
    }
  }
}, _client = new WeakMap(), _currentQuery = new WeakMap(), _currentQueryInitialState = new WeakMap(), _currentResult = new WeakMap(), _currentResultState = new WeakMap(), _currentResultOptions = new WeakMap(), _currentThenable = new WeakMap(), _selectError = new WeakMap(), _selectFn = new WeakMap(), _selectResult = new WeakMap(), _lastQueryWithDefinedData = new WeakMap(), _staleTimeoutId = new WeakMap(), _refetchIntervalId = new WeakMap(), _currentRefetchInterval = new WeakMap(), _trackedProps = new WeakMap(), _QueryObserver_instances = new WeakSet(), executeFetch_fn = function(fetchOptions) {
  __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);
  let promise = __privateGet(this, _currentQuery).fetch(
    this.options,
    fetchOptions
  );
  if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {
    promise = promise.catch(noop);
  }
  return promise;
}, updateStaleTimeout_fn = function() {
  __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);
  const staleTime = resolveStaleTime(
    this.options.staleTime,
    __privateGet(this, _currentQuery)
  );
  if (isServer || __privateGet(this, _currentResult).isStale || !isValidTimeout(staleTime)) {
    return;
  }
  const time = timeUntilStale(__privateGet(this, _currentResult).dataUpdatedAt, staleTime);
  const timeout = time + 1;
  __privateSet(this, _staleTimeoutId, setTimeout(() => {
    if (!__privateGet(this, _currentResult).isStale) {
      this.updateResult();
    }
  }, timeout));
}, computeRefetchInterval_fn = function() {
  return (typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(__privateGet(this, _currentQuery)) : this.options.refetchInterval) ?? false;
}, updateRefetchInterval_fn = function(nextInterval) {
  __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);
  __privateSet(this, _currentRefetchInterval, nextInterval);
  if (isServer || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) === false || !isValidTimeout(__privateGet(this, _currentRefetchInterval)) || __privateGet(this, _currentRefetchInterval) === 0) {
    return;
  }
  __privateSet(this, _refetchIntervalId, setInterval(() => {
    if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
      __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
    }
  }, __privateGet(this, _currentRefetchInterval)));
}, updateTimers_fn = function() {
  __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);
  __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this));
}, clearStaleTimeout_fn = function() {
  if (__privateGet(this, _staleTimeoutId)) {
    clearTimeout(__privateGet(this, _staleTimeoutId));
    __privateSet(this, _staleTimeoutId, void 0);
  }
}, clearRefetchInterval_fn = function() {
  if (__privateGet(this, _refetchIntervalId)) {
    clearInterval(__privateGet(this, _refetchIntervalId));
    __privateSet(this, _refetchIntervalId, void 0);
  }
}, updateQuery_fn = function() {
  const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), this.options);
  if (query === __privateGet(this, _currentQuery)) {
    return;
  }
  const prevQuery = __privateGet(this, _currentQuery);
  __privateSet(this, _currentQuery, query);
  __privateSet(this, _currentQueryInitialState, query.state);
  if (this.hasListeners()) {
    prevQuery == null ? void 0 : prevQuery.removeObserver(this);
    query.addObserver(this);
  }
}, notify_fn = function(notifyOptions) {
  notifyManager.batch(() => {
    if (notifyOptions.listeners) {
      this.listeners.forEach((listener) => {
        listener(__privateGet(this, _currentResult));
      });
    }
    __privateGet(this, _client).getQueryCache().notify({
      query: __privateGet(this, _currentQuery),
      type: "observerResultsUpdated"
    });
  });
}, _a9);
function shouldLoadOnMount(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === "error" && options.retryOnMount === false);
}
function shouldFetchOnMount(query, options) {
  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);
}
function shouldFetchOn(query, options, field) {
  if (resolveEnabled(options.enabled, query) !== false) {
    const value = typeof field === "function" ? field(query) : field;
    return value === "always" || value !== false && isStale(query, options);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
}
function isStale(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));
}
function shouldAssignObserverCurrentProperties(observer, optimisticResult) {
  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
    return true;
  }
  return false;
}

// node_modules/@tanstack/query-core/build/modern/infiniteQueryObserver.js
var InfiniteQueryObserver = class extends QueryObserver {
  constructor(client, options) {
    super(client, options);
  }
  bindMethods() {
    super.bindMethods();
    this.fetchNextPage = this.fetchNextPage.bind(this);
    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
  }
  setOptions(options, notifyOptions) {
    super.setOptions(
      {
        ...options,
        behavior: infiniteQueryBehavior()
      },
      notifyOptions
    );
  }
  getOptimisticResult(options) {
    options.behavior = infiniteQueryBehavior();
    return super.getOptimisticResult(options);
  }
  fetchNextPage(options) {
    return this.fetch({
      ...options,
      meta: {
        fetchMore: { direction: "forward" }
      }
    });
  }
  fetchPreviousPage(options) {
    return this.fetch({
      ...options,
      meta: {
        fetchMore: { direction: "backward" }
      }
    });
  }
  createResult(query, options) {
    var _a11, _b;
    const { state } = query;
    const parentResult = super.createResult(query, options);
    const { isFetching, isRefetching, isError, isRefetchError } = parentResult;
    const fetchDirection = (_b = (_a11 = state.fetchMeta) == null ? void 0 : _a11.fetchMore) == null ? void 0 : _b.direction;
    const isFetchNextPageError = isError && fetchDirection === "forward";
    const isFetchingNextPage = isFetching && fetchDirection === "forward";
    const isFetchPreviousPageError = isError && fetchDirection === "backward";
    const isFetchingPreviousPage = isFetching && fetchDirection === "backward";
    const result = {
      ...parentResult,
      fetchNextPage: this.fetchNextPage,
      fetchPreviousPage: this.fetchPreviousPage,
      hasNextPage: hasNextPage(options, state.data),
      hasPreviousPage: hasPreviousPage(options, state.data),
      isFetchNextPageError,
      isFetchingNextPage,
      isFetchPreviousPageError,
      isFetchingPreviousPage,
      isRefetchError: isRefetchError && !isFetchNextPageError && !isFetchPreviousPageError,
      isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage
    };
    return result;
  }
};

// node_modules/@tanstack/query-core/build/modern/mutationObserver.js
var _client2, _currentResult2, _currentMutation, _mutateOptions, _MutationObserver_instances, updateResult_fn, notify_fn2, _a10;
var MutationObserver = (_a10 = class extends Subscribable {
  constructor(client, options) {
    super();
    __privateAdd(this, _MutationObserver_instances);
    __privateAdd(this, _client2);
    __privateAdd(this, _currentResult2);
    __privateAdd(this, _currentMutation);
    __privateAdd(this, _mutateOptions);
    __privateSet(this, _client2, client);
    this.setOptions(options);
    this.bindMethods();
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options) {
    var _a11;
    const prevOptions = this.options;
    this.options = __privateGet(this, _client2).defaultMutationOptions(options);
    if (!shallowEqualObjects(this.options, prevOptions)) {
      __privateGet(this, _client2).getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: __privateGet(this, _currentMutation),
        observer: this
      });
    }
    if ((prevOptions == null ? void 0 : prevOptions.mutationKey) && this.options.mutationKey && hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)) {
      this.reset();
    } else if (((_a11 = __privateGet(this, _currentMutation)) == null ? void 0 : _a11.state.status) === "pending") {
      __privateGet(this, _currentMutation).setOptions(this.options);
    }
  }
  onUnsubscribe() {
    var _a11;
    if (!this.hasListeners()) {
      (_a11 = __privateGet(this, _currentMutation)) == null ? void 0 : _a11.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
    __privateMethod(this, _MutationObserver_instances, notify_fn2).call(this, action);
  }
  getCurrentResult() {
    return __privateGet(this, _currentResult2);
  }
  reset() {
    var _a11;
    (_a11 = __privateGet(this, _currentMutation)) == null ? void 0 : _a11.removeObserver(this);
    __privateSet(this, _currentMutation, void 0);
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
    __privateMethod(this, _MutationObserver_instances, notify_fn2).call(this);
  }
  mutate(variables, options) {
    var _a11;
    __privateSet(this, _mutateOptions, options);
    (_a11 = __privateGet(this, _currentMutation)) == null ? void 0 : _a11.removeObserver(this);
    __privateSet(this, _currentMutation, __privateGet(this, _client2).getMutationCache().build(__privateGet(this, _client2), this.options));
    __privateGet(this, _currentMutation).addObserver(this);
    return __privateGet(this, _currentMutation).execute(variables);
  }
}, _client2 = new WeakMap(), _currentResult2 = new WeakMap(), _currentMutation = new WeakMap(), _mutateOptions = new WeakMap(), _MutationObserver_instances = new WeakSet(), updateResult_fn = function() {
  var _a11;
  const state = ((_a11 = __privateGet(this, _currentMutation)) == null ? void 0 : _a11.state) ?? getDefaultState2();
  __privateSet(this, _currentResult2, {
    ...state,
    isPending: state.status === "pending",
    isSuccess: state.status === "success",
    isError: state.status === "error",
    isIdle: state.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, notify_fn2 = function(action) {
  notifyManager.batch(() => {
    var _a11, _b, _c, _d, _e, _f, _g, _h;
    if (__privateGet(this, _mutateOptions) && this.hasListeners()) {
      const variables = __privateGet(this, _currentResult2).variables;
      const context = __privateGet(this, _currentResult2).context;
      if ((action == null ? void 0 : action.type) === "success") {
        (_b = (_a11 = __privateGet(this, _mutateOptions)).onSuccess) == null ? void 0 : _b.call(_a11, action.data, variables, context);
        (_d = (_c = __privateGet(this, _mutateOptions)).onSettled) == null ? void 0 : _d.call(_c, action.data, null, variables, context);
      } else if ((action == null ? void 0 : action.type) === "error") {
        (_f = (_e = __privateGet(this, _mutateOptions)).onError) == null ? void 0 : _f.call(_e, action.error, variables, context);
        (_h = (_g = __privateGet(this, _mutateOptions)).onSettled) == null ? void 0 : _h.call(
          _g,
          void 0,
          action.error,
          variables,
          context
        );
      }
    }
    this.listeners.forEach((listener) => {
      listener(__privateGet(this, _currentResult2));
    });
  });
}, _a10);

// node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js
var React = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var QueryClientContext = React.createContext(
  void 0
);
var useQueryClient = (queryClient) => {
  const client = React.useContext(QueryClientContext);
  if (queryClient) {
    return queryClient;
  }
  if (!client) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return client;
};
var QueryClientProvider = ({
  client,
  children
}) => {
  React.useEffect(() => {
    client.mount();
    return () => {
      client.unmount();
    };
  }, [client]);
  return (0, import_jsx_runtime.jsx)(QueryClientContext.Provider, { value: client, children });
};

// node_modules/@tanstack/react-query/build/modern/useMutation.js
var React2 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/modern/utils.js
function shouldThrowError(throwError, params) {
  if (typeof throwError === "function") {
    return throwError(...params);
  }
  return !!throwError;
}
function noop2() {
}

// node_modules/@tanstack/react-query/build/modern/useMutation.js
function useMutation(options, queryClient) {
  const client = useQueryClient(queryClient);
  const [observer] = React2.useState(
    () => new MutationObserver(
      client,
      options
    )
  );
  React2.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = React2.useSyncExternalStore(
    React2.useCallback(
      (onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)),
      [observer]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  const mutate = React2.useCallback(
    (variables, mutateOptions) => {
      observer.mutate(variables, mutateOptions).catch(noop2);
    },
    [observer]
  );
  if (result.error && shouldThrowError(observer.options.throwOnError, [result.error])) {
    throw result.error;
  }
  return { ...result, mutate, mutateAsync: result.mutate };
}

// node_modules/@tanstack/react-query/build/modern/useBaseQuery.js
var React6 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js
var React3 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    }
  };
}
var QueryErrorResetBoundaryContext = React3.createContext(createValue());
var useQueryErrorResetBoundary = () => React3.useContext(QueryErrorResetBoundaryContext);

// node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js
var React4 = __toESM(require_react(), 1);
var ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {
  if (options.suspense || options.throwOnError) {
    if (!errorResetBoundary.isReset()) {
      options.retryOnMount = false;
    }
  }
};
var useClearResetErrorBoundary = (errorResetBoundary) => {
  React4.useEffect(() => {
    errorResetBoundary.clearReset();
  }, [errorResetBoundary]);
};
var getHasError = ({
  result,
  errorResetBoundary,
  throwOnError,
  query
}) => {
  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && shouldThrowError(throwOnError, [result.error, query]);
};

// node_modules/@tanstack/react-query/build/modern/isRestoring.js
var React5 = __toESM(require_react(), 1);
var IsRestoringContext = React5.createContext(false);
var useIsRestoring = () => React5.useContext(IsRestoringContext);
var IsRestoringProvider = IsRestoringContext.Provider;

// node_modules/@tanstack/react-query/build/modern/suspense.js
var ensureSuspenseTimers = (defaultedOptions) => {
  if (defaultedOptions.suspense) {
    if (typeof defaultedOptions.staleTime !== "number") {
      defaultedOptions.staleTime = 1e3;
    }
    if (typeof defaultedOptions.gcTime === "number") {
      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1e3);
    }
  }
};
var willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;
var shouldSuspend = (defaultedOptions, result) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && result.isPending;
var fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {
  errorResetBoundary.clearReset();
});

// node_modules/@tanstack/react-query/build/modern/useBaseQuery.js
function useBaseQuery(options, Observer, queryClient) {
  var _a11, _b, _c, _d, _e;
  if (true) {
    if (typeof options !== "object" || Array.isArray(options)) {
      throw new Error(
        'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
      );
    }
  }
  const client = useQueryClient(queryClient);
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const defaultedOptions = client.defaultQueryOptions(options);
  (_b = (_a11 = client.getDefaultOptions().queries) == null ? void 0 : _a11._experimental_beforeQuery) == null ? void 0 : _b.call(
    _a11,
    defaultedOptions
  );
  defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
  ensureSuspenseTimers(defaultedOptions);
  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
  useClearResetErrorBoundary(errorResetBoundary);
  const isNewCacheEntry = !client.getQueryState(options.queryKey);
  const [observer] = React6.useState(
    () => new Observer(
      client,
      defaultedOptions
    )
  );
  const result = observer.getOptimisticResult(defaultedOptions);
  React6.useSyncExternalStore(
    React6.useCallback(
      (onStoreChange) => {
        const unsubscribe = isRestoring ? () => void 0 : observer.subscribe(notifyManager.batchCalls(onStoreChange));
        observer.updateResult();
        return unsubscribe;
      },
      [observer, isRestoring]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  React6.useEffect(() => {
    observer.setOptions(defaultedOptions, { listeners: false });
  }, [defaultedOptions, observer]);
  if (shouldSuspend(defaultedOptions, result)) {
    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
  }
  if (getHasError({
    result,
    errorResetBoundary,
    throwOnError: defaultedOptions.throwOnError,
    query: client.getQueryCache().get(defaultedOptions.queryHash)
  })) {
    throw result.error;
  }
  ;
  (_d = (_c = client.getDefaultOptions().queries) == null ? void 0 : _c._experimental_afterQuery) == null ? void 0 : _d.call(
    _c,
    defaultedOptions,
    result
  );
  if (defaultedOptions.experimental_prefetchInRender && !isServer && willFetch(result, isRestoring)) {
    const promise = isNewCacheEntry ? (
      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
      fetchOptimistic(defaultedOptions, observer, errorResetBoundary)
    ) : (
      // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
      (_e = client.getQueryCache().get(defaultedOptions.queryHash)) == null ? void 0 : _e.promise
    );
    promise == null ? void 0 : promise.catch(noop2).finally(() => {
      if (!observer.hasListeners()) {
        observer.updateResult();
      }
    });
  }
  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}

// node_modules/@tanstack/react-query/build/modern/useInfiniteQuery.js
function useInfiniteQuery(options, queryClient) {
  return useBaseQuery(
    options,
    InfiniteQueryObserver,
    queryClient
  );
}

// node_modules/@tanstack/react-query/build/modern/useQueries.js
var React7 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/modern/useQuery.js
function useQuery(options, queryClient) {
  return useBaseQuery(options, QueryObserver, queryClient);
}

// node_modules/@tanstack/react-query/build/modern/HydrationBoundary.js
var React8 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/modern/useIsFetching.js
var React9 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/modern/useMutationState.js
var React10 = __toESM(require_react(), 1);

// node_modules/@medusajs/js-sdk/dist/esm/admin/api-key.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ApiKey = class {
  constructor(client) {
    this.client = client;
  }
  list(queryParams, headers) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/api-keys`, {
        query: queryParams,
        headers
      });
    });
  }
  create(body, query, headers) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/api-keys`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  revoke(id, headers) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/api-keys/${id}/revoke`, {
        method: "POST",
        headers
      });
    });
  }
  retrieve(id, headers) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/api-keys/${id}`, {
        headers
      });
    });
  }
  update(id, body, query, headers) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/api-keys/${id}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  delete(id, headers) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/api-keys/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
  batchSalesChannels(id, body, headers) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/api-keys/${id}/sales-channels`, {
        method: "POST",
        headers,
        body
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/campaign.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Campaign = class {
  constructor(client) {
    this.client = client;
  }
  retrieve(id, query, headers) {
    return __awaiter2(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/campaigns/${id}`, {
        headers,
        query
      });
    });
  }
  list(query, headers) {
    return __awaiter2(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/campaigns`, {
        headers,
        query
      });
    });
  }
  create(payload, headers) {
    return __awaiter2(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/campaigns`, {
        method: "POST",
        headers,
        body: payload
      });
    });
  }
  update(id, payload, headers) {
    return __awaiter2(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/campaigns/${id}`, {
        method: "POST",
        headers,
        body: payload
      });
    });
  }
  delete(id, headers) {
    return __awaiter2(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/campaigns/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
  batchPromotions(id, payload, headers) {
    return __awaiter2(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/campaigns/${id}/promotions`, {
        method: "POST",
        headers,
        body: payload
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/claim.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Claim = class {
  constructor(client) {
    this.client = client;
  }
  list(query, headers) {
    return __awaiter3(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/claims`, {
        query,
        headers
      });
    });
  }
  retrieve(id, query, headers) {
    return __awaiter3(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/claims/${id}`, {
        query,
        headers
      });
    });
  }
  create(body, query, headers) {
    return __awaiter3(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/claims`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  cancel(id, query, headers) {
    return __awaiter3(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/claims/${id}/cancel`, {
        method: "POST",
        headers,
        query
      });
    });
  }
  delete(id, query, headers) {
    return __awaiter3(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/claims/${id}`, {
        method: "DELETE",
        headers,
        query
      });
    });
  }
  addItems(id, body, query, headers) {
    return __awaiter3(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/claims/${id}/claim-items`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  updateItem(id, actionId, body, query, headers) {
    return __awaiter3(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/claims/${id}/claim-items/${actionId}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  removeItem(id, actionId, query, headers) {
    return __awaiter3(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/claims/${id}/claim-items/${actionId}`, {
        method: "DELETE",
        headers,
        query
      });
    });
  }
  addInboundItems(id, body, query, headers) {
    return __awaiter3(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/claims/${id}/inbound/items`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  updateInboundItem(id, actionId, body, query, headers) {
    return __awaiter3(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/claims/${id}/inbound/items/${actionId}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  removeInboundItem(id, actionId, query, headers) {
    return __awaiter3(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/claims/${id}/inbound/items/${actionId}`, {
        method: "DELETE",
        headers,
        query
      });
    });
  }
  addInboundShipping(id, body, query, headers) {
    return __awaiter3(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/claims/${id}/inbound/shipping-method`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  updateInboundShipping(id, actionId, body, query, headers) {
    return __awaiter3(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/claims/${id}/inbound/shipping-method/${actionId}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  deleteInboundShipping(id, actionId, query, headers) {
    return __awaiter3(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/claims/${id}/inbound/shipping-method/${actionId}`, {
        method: "DELETE",
        headers,
        query
      });
    });
  }
  addOutboundItems(id, body, query, headers) {
    return __awaiter3(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/claims/${id}/outbound/items`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  updateOutboundItem(id, actionId, body, query, headers) {
    return __awaiter3(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/claims/${id}/outbound/items/${actionId}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  removeOutboundItem(id, actionId, query, headers) {
    return __awaiter3(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/claims/${id}/outbound/items/${actionId}`, {
        method: "DELETE",
        headers,
        query
      });
    });
  }
  addOutboundShipping(id, body, query, headers) {
    return __awaiter3(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/claims/${id}/outbound/shipping-method`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  updateOutboundShipping(id, actionId, body, query, headers) {
    return __awaiter3(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/claims/${id}/outbound/shipping-method/${actionId}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  deleteOutboundShipping(id, actionId, query, headers) {
    return __awaiter3(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/claims/${id}/outbound/shipping-method/${actionId}`, {
        method: "DELETE",
        headers,
        query
      });
    });
  }
  request(id, body, query, headers) {
    return __awaiter3(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/claims/${id}/request`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  cancelRequest(id, query, headers) {
    return __awaiter3(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/claims/${id}/request`, {
        method: "DELETE",
        headers,
        query
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/currency.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Currency = class {
  constructor(client) {
    this.client = client;
  }
  list(query, headers) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/currencies`, {
        headers,
        query
      });
    });
  }
  retrieve(id, query, headers) {
    return __awaiter4(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/currencies/${id}`, {
        headers,
        query
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/customer.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Customer = class {
  constructor(client) {
    this.client = client;
  }
  create(body, query, headers) {
    return __awaiter5(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/customers`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  update(id, body, query, headers) {
    return __awaiter5(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/customers/${id}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  list(queryParams, headers) {
    return __awaiter5(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/customers`, {
        headers,
        query: queryParams
      });
    });
  }
  retrieve(id, query, headers) {
    return __awaiter5(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/customers/${id}`, {
        query,
        headers
      });
    });
  }
  delete(id, headers) {
    return __awaiter5(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/customers/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/customer-group.js
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CustomerGroup = class {
  constructor(client) {
    this.client = client;
  }
  retrieve(id, query, headers) {
    return __awaiter6(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/customer-groups/${id}`, {
        method: "GET",
        query,
        headers
      });
    });
  }
  list(query, headers) {
    return __awaiter6(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/customer-groups`, {
        method: "GET",
        headers,
        query
      });
    });
  }
  create(body, query, headers) {
    return __awaiter6(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/customer-groups`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  update(id, body, query, headers) {
    return __awaiter6(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/customer-groups/${id}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  delete(id, headers) {
    return __awaiter6(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/customer-groups/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
  batchCustomers(id, body, headers) {
    return __awaiter6(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/customer-groups/${id}/customers`, {
        method: "POST",
        headers,
        body
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/exchange.js
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Exchange = class {
  constructor(client) {
    this.client = client;
  }
  list(query, headers) {
    return __awaiter7(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/exchanges`, {
        query,
        headers
      });
    });
  }
  retrieve(id, query, headers) {
    return __awaiter7(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/exchanges/${id}`, {
        query,
        headers
      });
    });
  }
  create(body, query, headers) {
    return __awaiter7(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/exchanges`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  cancel(id, query, headers) {
    return __awaiter7(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/exchanges/${id}/cancel`, {
        method: "POST",
        headers,
        query
      });
    });
  }
  delete(id, query, headers) {
    return __awaiter7(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/exchanges/${id}`, {
        method: "DELETE",
        headers,
        query
      });
    });
  }
  addItems(id, body, query, headers) {
    return __awaiter7(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/exchanges/${id}/exchange-items`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  updateItem(id, actionId, body, query, headers) {
    return __awaiter7(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/exchanges/${id}/exchange-items/${actionId}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  removeItem(id, actionId, query, headers) {
    return __awaiter7(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/exchanges/${id}/exchange-items/${actionId}`, {
        method: "DELETE",
        headers,
        query
      });
    });
  }
  addInboundItems(id, body, query, headers) {
    return __awaiter7(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/exchanges/${id}/inbound/items`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  updateInboundItem(id, actionId, body, query, headers) {
    return __awaiter7(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/exchanges/${id}/inbound/items/${actionId}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  removeInboundItem(id, actionId, query, headers) {
    return __awaiter7(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/exchanges/${id}/inbound/items/${actionId}`, {
        method: "DELETE",
        headers,
        query
      });
    });
  }
  addInboundShipping(id, body, query, headers) {
    return __awaiter7(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/exchanges/${id}/inbound/shipping-method`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  updateInboundShipping(id, actionId, body, query, headers) {
    return __awaiter7(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/exchanges/${id}/inbound/shipping-method/${actionId}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  deleteInboundShipping(id, actionId, query, headers) {
    return __awaiter7(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/exchanges/${id}/inbound/shipping-method/${actionId}`, {
        method: "DELETE",
        headers,
        query
      });
    });
  }
  addOutboundItems(id, body, query, headers) {
    return __awaiter7(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/exchanges/${id}/outbound/items`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  updateOutboundItem(id, actionId, body, query, headers) {
    return __awaiter7(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/exchanges/${id}/outbound/items/${actionId}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  removeOutboundItem(id, actionId, query, headers) {
    return __awaiter7(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/exchanges/${id}/outbound/items/${actionId}`, {
        method: "DELETE",
        headers,
        query
      });
    });
  }
  addOutboundShipping(id, body, query, headers) {
    return __awaiter7(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/exchanges/${id}/outbound/shipping-method`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  updateOutboundShipping(id, actionId, body, query, headers) {
    return __awaiter7(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/exchanges/${id}/outbound/shipping-method/${actionId}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  deleteOutboundShipping(id, actionId, query, headers) {
    return __awaiter7(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/exchanges/${id}/outbound/shipping-method/${actionId}`, {
        method: "DELETE",
        headers,
        query
      });
    });
  }
  request(id, body, query, headers) {
    return __awaiter7(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/exchanges/${id}/request`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  cancelRequest(id, query, headers) {
    return __awaiter7(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/exchanges/${id}/request`, {
        method: "DELETE",
        headers,
        query
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/fulfillment.js
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Fulfillment = class {
  constructor(client) {
    this.client = client;
  }
  create(body, query, headers) {
    return __awaiter8(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/fulfillments`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  cancel(id, query, headers) {
    return __awaiter8(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/fulfillments/${id}`, {
        method: "POST",
        body: {},
        headers
      });
    });
  }
  createShipment(id, body, query, headers) {
    return __awaiter8(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/fulfillments/${id}/shipment`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/fulfillment-provider.js
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var FulfillmentProvider = class {
  constructor(client) {
    this.client = client;
  }
  list(query, headers) {
    return __awaiter9(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/fulfillment-providers`, {
        method: "GET",
        headers,
        query
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/fulfillment-set.js
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var FulfillmentSet = class {
  constructor(client) {
    this.client = client;
  }
  delete(id, headers) {
    return __awaiter10(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/fulfillment-sets/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
  createServiceZone(id, body, query, headers) {
    return __awaiter10(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/fulfillment-sets/${id}/service-zones`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  retrieveServiceZone(fulfillmentSetId, serviceZoneId, query, headers) {
    return __awaiter10(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/fulfillment-sets/${fulfillmentSetId}/service-zones/${serviceZoneId}`, {
        method: "GET",
        headers,
        query
      });
    });
  }
  updateServiceZone(fulfillmentSetId, serviceZoneId, body, query, headers) {
    return __awaiter10(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/fulfillment-sets/${fulfillmentSetId}/service-zones/${serviceZoneId}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  deleteServiceZone(fulfillmentSetId, serviceZoneId, headers) {
    return __awaiter10(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/fulfillment-sets/${fulfillmentSetId}/service-zones/${serviceZoneId}`, {
        method: "DELETE",
        headers
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/inventory-item.js
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var InventoryItem = class {
  constructor(client) {
    this.client = client;
  }
  create(body, query, headers) {
    return __awaiter11(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/inventory-items`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  update(id, body, query, headers) {
    return __awaiter11(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/inventory-items/${id}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  list(query, headers) {
    return __awaiter11(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/inventory-items`, {
        query,
        headers
      });
    });
  }
  retrieve(id, query, headers) {
    return __awaiter11(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/inventory-items/${id}`, {
        query,
        headers
      });
    });
  }
  delete(id, headers) {
    return __awaiter11(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/inventory-items/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
  listLevels(id, query, headers) {
    return __awaiter11(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/inventory-items/${id}/location-levels`, {
        query,
        headers
      });
    });
  }
  updateLevel(id, locationId, body, query, headers) {
    return __awaiter11(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/inventory-items/${id}/location-levels/${locationId}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  deleteLevel(id, locationId, headers) {
    return __awaiter11(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/inventory-items/${id}/location-levels/${locationId}`, {
        method: "DELETE",
        headers
      });
    });
  }
  batchUpdateLevels(id, body, query, headers) {
    return __awaiter11(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/inventory-items/${id}/location-levels/batch`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/invite.js
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Invite = class {
  constructor(client) {
    this.client = client;
  }
  accept(input, query, headers) {
    return __awaiter12(this, void 0, void 0, function* () {
      const { invite_token } = input, rest = __rest(input, ["invite_token"]);
      return yield this.client.fetch(`/admin/invites/accept?token=${input.invite_token}`, {
        method: "POST",
        headers,
        body: rest,
        query
      });
    });
  }
  create(body, query, headers) {
    return __awaiter12(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/invites`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  retrieve(id, query, headers) {
    return __awaiter12(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/invites/${id}`, {
        headers,
        query
      });
    });
  }
  list(queryParams, headers) {
    return __awaiter12(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/invites`, {
        headers,
        query: queryParams
      });
    });
  }
  resend(id, headers) {
    return __awaiter12(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/invites/${id}/resend`, {
        method: "POST",
        headers
      });
    });
  }
  delete(id, headers) {
    return __awaiter12(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/invites/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/notification.js
var __awaiter13 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Notification = class {
  constructor(client) {
    this.client = client;
  }
  retrieve(id, query, headers) {
    return __awaiter13(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/notifications/${id}`, {
        method: "GET",
        headers,
        query
      });
    });
  }
  list(query, headers) {
    return __awaiter13(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/notifications`, {
        method: "GET",
        headers,
        query
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/order.js
var __awaiter14 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Order = class {
  constructor(client) {
    this.client = client;
  }
  retrieve(id, query, headers) {
    return __awaiter14(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/orders/${id}`, {
        query,
        headers
      });
    });
  }
  retrievePreview(id, query, headers) {
    return __awaiter14(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/orders/${id}/preview`, {
        query,
        headers
      });
    });
  }
  list(queryParams, headers) {
    return __awaiter14(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/orders`, {
        query: queryParams,
        headers
      });
    });
  }
  cancel(id, headers) {
    return __awaiter14(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/orders/${id}/cancel`, {
        method: "POST",
        headers
      });
    });
  }
  createFulfillment(id, body, query, headers) {
    return __awaiter14(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/orders/${id}/fulfillments`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  cancelFulfillment(id, fulfillmentId, body, headers) {
    return __awaiter14(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/orders/${id}/fulfillments/${fulfillmentId}/cancel`, {
        method: "POST",
        headers,
        body
      });
    });
  }
  createShipment(id, fulfillmentId, body, query, headers) {
    return __awaiter14(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/orders/${id}/fulfillments/${fulfillmentId}/shipments`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  markAsDelivered(id, fulfillmentId, body, query, headers) {
    return __awaiter14(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/orders/${id}/fulfillments/${fulfillmentId}/mark-as-delivered`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  listChanges(id, queryParams, headers) {
    return __awaiter14(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/orders/${id}/changes`, {
        query: queryParams,
        headers
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/order-edit.js
var __awaiter15 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var OrderEdit = class {
  constructor(client) {
    this.client = client;
  }
  initiateRequest(body, query, headers) {
    return __awaiter15(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/order-edits`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  request(id, query, headers) {
    return __awaiter15(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/order-edits/${id}/request`, {
        method: "POST",
        headers,
        query
      });
    });
  }
  confirm(id, query, headers) {
    return __awaiter15(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/order-edits/${id}/confirm`, {
        method: "POST",
        headers,
        query
      });
    });
  }
  cancelRequest(id, query, headers) {
    return __awaiter15(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/order-edits/${id}`, {
        method: "DELETE",
        headers,
        query
      });
    });
  }
  addItems(id, body, query, headers) {
    return __awaiter15(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/order-edits/${id}/items`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  updateOriginalItem(id, itemId, body, query, headers) {
    return __awaiter15(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/order-edits/${id}/items/item/${itemId}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  updateAddedItem(id, actionId, body, query, headers) {
    return __awaiter15(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/order-edits/${id}/items/${actionId}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  removeAddedItem(id, actionId, query, headers) {
    return __awaiter15(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/order-edits/${id}/items/${actionId}`, {
        method: "DELETE",
        headers,
        query
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/payment.js
var __awaiter16 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Payment = class {
  constructor(client) {
    this.client = client;
  }
  list(query, headers) {
    return __awaiter16(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/payments`, {
        query,
        headers
      });
    });
  }
  listPaymentProviders(query, headers) {
    return __awaiter16(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/payments/payment-providers`, {
        query,
        headers
      });
    });
  }
  retrieve(id, query, headers) {
    return __awaiter16(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/payments/${id}`, {
        query,
        headers
      });
    });
  }
  capture(id, body, query, headers) {
    return __awaiter16(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/payments/${id}/capture`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  refund(id, body, query, headers) {
    return __awaiter16(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/payments/${id}/refund`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/payment-collection.js
var __awaiter17 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PaymentCollection = class {
  constructor(client) {
    this.client = client;
  }
  list(query, headers) {
    return __awaiter17(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/payment-collections`, {
        query,
        headers
      });
    });
  }
  retrieve(id, query, headers) {
    return __awaiter17(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/payment-collections/${id}`, {
        query,
        headers
      });
    });
  }
  create(body, query, headers) {
    return __awaiter17(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/payment-collections`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  delete(id, headers) {
    return __awaiter17(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/payment-collections/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
  markAsPaid(id, body, query, headers) {
    return __awaiter17(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/payment-collections/${id}/mark-as-paid`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/price-list.js
var __awaiter18 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PriceList = class {
  constructor(client) {
    this.client = client;
  }
  retrieve(id, query, headers) {
    return __awaiter18(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/price-lists/${id}`, {
        method: "GET",
        headers,
        query
      });
    });
  }
  list(query, headers) {
    return __awaiter18(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/price-lists`, {
        method: "GET",
        headers,
        query
      });
    });
  }
  create(body, query, headers) {
    return __awaiter18(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/price-lists`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  update(id, body, query, headers) {
    return __awaiter18(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/price-lists/${id}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  delete(id, headers) {
    return __awaiter18(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/price-lists/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
  batchPrices(id, body, query, headers) {
    return __awaiter18(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/price-lists/${id}/prices/batch`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  linkProducts(id, body, query, headers) {
    return __awaiter18(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/price-lists/${id}/products`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/price-preference.js
var __awaiter19 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PricePreference = class {
  constructor(client) {
    this.client = client;
  }
  retrieve(id, query, headers) {
    return __awaiter19(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/price-preferences/${id}`, {
        method: "GET",
        headers,
        query
      });
    });
  }
  list(query, headers) {
    return __awaiter19(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/price-preferences`, {
        method: "GET",
        headers,
        query
      });
    });
  }
  create(body, query, headers) {
    return __awaiter19(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/price-preferences`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  update(id, body, query, headers) {
    return __awaiter19(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/price-preferences/${id}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  delete(id, headers) {
    return __awaiter19(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/price-preferences/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/product.js
var __awaiter20 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Product = class {
  constructor(client) {
    this.client = client;
  }
  import(body, query, headers) {
    return __awaiter20(this, void 0, void 0, function* () {
      const form = new FormData();
      form.append("file", body.file);
      return yield this.client.fetch(`/admin/products/import`, {
        method: "POST",
        headers: Object.assign(Object.assign({}, headers), {
          // Let the browser determine the content type.
          "content-type": null
        }),
        body: form,
        query
      });
    });
  }
  confirmImport(transactionId, query, headers) {
    return __awaiter20(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/products/import/${transactionId}/confirm`, {
        method: "POST",
        headers,
        body: {},
        query
      });
    });
  }
  export(body, query, headers) {
    return __awaiter20(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/products/export`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  batch(body, query, headers) {
    return __awaiter20(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/products/batch`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  create(body, query, headers) {
    return __awaiter20(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/products`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  update(id, body, query, headers) {
    return __awaiter20(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/products/${id}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  list(queryParams, headers) {
    return __awaiter20(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/products`, {
        headers,
        query: queryParams
      });
    });
  }
  retrieve(id, query, headers) {
    return __awaiter20(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/products/${id}`, {
        query,
        headers
      });
    });
  }
  delete(id, headers) {
    return __awaiter20(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/products/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
  batchVariants(productId, body, query, headers) {
    return __awaiter20(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/products/${productId}/variants/batch`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  createVariant(productId, body, query, headers) {
    return __awaiter20(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/products/${productId}/variants`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  updateVariant(productId, id, body, query, headers) {
    return __awaiter20(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/products/${productId}/variants/${id}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  listVariants(productId, queryParams, headers) {
    return __awaiter20(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/products/${productId}/variants`, {
        headers,
        query: queryParams
      });
    });
  }
  retrieveVariant(productId, id, query, headers) {
    return __awaiter20(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/products/${productId}/variants/${id}`, {
        query,
        headers
      });
    });
  }
  deleteVariant(productId, id, headers) {
    return __awaiter20(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/products/${productId}/variants/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
  batchVariantInventoryItems(productId, body, query, headers) {
    return __awaiter20(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/products/${productId}/variants/inventory-items/batch`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  createOption(productId, body, query, headers) {
    return __awaiter20(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/products/${productId}/options`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  updateOption(productId, id, body, query, headers) {
    return __awaiter20(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/products/${productId}/options/${id}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  listOptions(productId, queryParams, headers) {
    return __awaiter20(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/products/${productId}/options`, {
        headers,
        query: queryParams
      });
    });
  }
  retrieveOption(productId, id, query, headers) {
    return __awaiter20(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/products/${productId}/options/${id}`, {
        query,
        headers
      });
    });
  }
  deleteOption(productId, id, headers) {
    return __awaiter20(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/products/${productId}/options/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/product-category.js
var __awaiter21 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ProductCategory = class {
  constructor(client) {
    this.client = client;
  }
  create(body, query, headers) {
    return __awaiter21(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/product-categories`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  update(id, body, query, headers) {
    return __awaiter21(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/product-categories/${id}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  list(query, headers) {
    return __awaiter21(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/product-categories`, {
        headers,
        query
      });
    });
  }
  retrieve(id, query, headers) {
    return __awaiter21(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/product-categories/${id}`, {
        query,
        headers
      });
    });
  }
  delete(id, headers) {
    return __awaiter21(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/product-categories/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
  updateProducts(id, body, query, headers) {
    return __awaiter21(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/product-categories/${id}/products`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/product-collection.js
var __awaiter22 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ProductCollection = class {
  constructor(client) {
    this.client = client;
  }
  create(body, query, headers) {
    return __awaiter22(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/collections`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  update(id, body, query, headers) {
    return __awaiter22(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/collections/${id}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  list(queryParams, headers) {
    return __awaiter22(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/collections`, {
        headers,
        query: queryParams
      });
    });
  }
  retrieve(id, query, headers) {
    return __awaiter22(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/collections/${id}`, {
        query,
        headers
      });
    });
  }
  delete(id, headers) {
    return __awaiter22(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/collections/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
  updateProducts(id, body, headers) {
    return __awaiter22(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/collections/${id}/products`, {
        method: "POST",
        headers,
        body
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/product-tag.js
var __awaiter23 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ProductTag = class {
  constructor(client) {
    this.client = client;
  }
  create(body, query, headers) {
    return __awaiter23(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/product-tags`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  update(id, body, query, headers) {
    return __awaiter23(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/product-tags/${id}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  list(query, headers) {
    return __awaiter23(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/product-tags`, {
        headers,
        query
      });
    });
  }
  retrieve(id, query, headers) {
    return __awaiter23(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/product-tags/${id}`, {
        query,
        headers
      });
    });
  }
  delete(id, headers) {
    return __awaiter23(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/product-tags/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/product-type.js
var __awaiter24 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ProductType = class {
  constructor(client) {
    this.client = client;
  }
  create(body, query, headers) {
    return __awaiter24(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/product-types`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  update(id, body, query, headers) {
    return __awaiter24(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/product-types/${id}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  list(query, headers) {
    return __awaiter24(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/product-types`, {
        headers,
        query
      });
    });
  }
  retrieve(id, query, headers) {
    return __awaiter24(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/product-types/${id}`, {
        query,
        headers
      });
    });
  }
  delete(id, headers) {
    return __awaiter24(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/product-types/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/product-variant.js
var __awaiter25 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ProductVariant = class {
  constructor(client) {
    this.client = client;
  }
  list(queryParams, headers) {
    return __awaiter25(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/product-variants`, {
        headers,
        query: queryParams
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/promotion.js
var __awaiter26 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Promotion = class {
  constructor(client) {
    this.client = client;
  }
  retrieve(id, query, headers) {
    return __awaiter26(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/promotions/${id}`, {
        headers,
        query
      });
    });
  }
  list(query, headers) {
    return __awaiter26(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/promotions`, {
        headers,
        query
      });
    });
  }
  create(payload, headers) {
    return __awaiter26(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/promotions`, {
        method: "POST",
        headers,
        body: payload
      });
    });
  }
  update(id, payload, headers) {
    return __awaiter26(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/promotions/${id}`, {
        method: "POST",
        headers,
        body: payload
      });
    });
  }
  delete(id, headers) {
    return __awaiter26(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/promotions/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
  addRules(id, ruleType, payload, headers) {
    return __awaiter26(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/promotions/${id}/${ruleType}/batch`, {
        method: "POST",
        headers,
        body: { create: payload.rules }
      });
    });
  }
  updateRules(id, ruleType, payload, headers) {
    return __awaiter26(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/promotions/${id}/${ruleType}/batch`, {
        method: "POST",
        headers,
        body: { update: payload.rules }
      });
    });
  }
  removeRules(id, ruleType, payload, headers) {
    return __awaiter26(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/promotions/${id}/${ruleType}/batch`, {
        method: "POST",
        headers,
        body: { delete: payload.rule_ids }
      });
    });
  }
  listRules(id, ruleType, query, headers) {
    return __awaiter26(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/promotions/${id}/${ruleType}`, {
        headers,
        query
      });
    });
  }
  listRuleAttributes(ruleType, promotionType, headers) {
    return __awaiter26(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/promotions/rule-attribute-options/${ruleType}`, {
        headers,
        query: { promotion_type: promotionType }
      });
    });
  }
  listRuleValues(ruleType, ruleValue, query, headers) {
    return __awaiter26(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/promotions/rule-value-options/${ruleType}/${ruleValue}`, {
        headers,
        query
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/refund-reasons.js
var __awaiter27 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var RefundReason = class {
  constructor(client) {
    this.client = client;
  }
  list(query, headers) {
    return __awaiter27(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/refund-reasons`, {
        query,
        headers
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/region.js
var __awaiter28 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Region = class {
  constructor(client) {
    this.client = client;
  }
  create(body, query, headers) {
    return __awaiter28(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/regions`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  update(id, body, query, headers) {
    return __awaiter28(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/regions/${id}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  list(queryParams, headers) {
    return __awaiter28(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/regions`, {
        query: queryParams,
        headers
      });
    });
  }
  retrieve(id, query, headers) {
    return __awaiter28(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/regions/${id}`, {
        query,
        headers
      });
    });
  }
  delete(id, headers) {
    return __awaiter28(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/regions/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/reservation.js
var __awaiter29 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Reservation = class {
  constructor(client) {
    this.client = client;
  }
  retrieve(id, query, headers) {
    return __awaiter29(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/reservations/${id}`, {
        method: "GET",
        headers,
        query
      });
    });
  }
  list(query, headers) {
    return __awaiter29(this, void 0, void 0, function* () {
      return yield this.client.fetch("/admin/reservations", {
        method: "GET",
        query,
        headers
      });
    });
  }
  create(body, query, headers) {
    return __awaiter29(this, void 0, void 0, function* () {
      return yield this.client.fetch("/admin/reservations", {
        method: "POST",
        body,
        query,
        headers
      });
    });
  }
  update(id, body, query, headers) {
    return __awaiter29(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/reservations/${id}`, {
        method: "POST",
        body,
        query,
        headers
      });
    });
  }
  delete(id, headers) {
    return __awaiter29(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/reservations/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
};
var reservation_default = Reservation;

// node_modules/@medusajs/js-sdk/dist/esm/admin/return.js
var __awaiter30 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Return = class {
  constructor(client) {
    this.client = client;
  }
  list(query, headers) {
    return __awaiter30(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/returns`, {
        query,
        headers
      });
    });
  }
  retrieve(id, query, headers) {
    return __awaiter30(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/returns/${id}`, {
        query,
        headers
      });
    });
  }
  initiateRequest(body, query, headers) {
    return __awaiter30(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/returns`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  cancel(id, query, headers) {
    return __awaiter30(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/returns/${id}/cancel`, {
        method: "POST",
        headers,
        query
      });
    });
  }
  cancelRequest(id, query, headers) {
    return __awaiter30(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/returns/${id}/request`, {
        method: "DELETE",
        headers,
        query
      });
    });
  }
  addReturnItem(id, body, query, headers) {
    return __awaiter30(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/returns/${id}/request-items`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  updateReturnItem(id, actionId, body, query, headers) {
    return __awaiter30(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/returns/${id}/request-items/${actionId}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  removeReturnItem(id, actionId, query, headers) {
    return __awaiter30(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/returns/${id}/request-items/${actionId}`, {
        method: "DELETE",
        headers,
        query
      });
    });
  }
  addReturnShipping(id, body, query, headers) {
    return __awaiter30(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/returns/${id}/shipping-method`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  updateReturnShipping(id, actionId, body, query, headers) {
    return __awaiter30(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/returns/${id}/shipping-method/${actionId}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  deleteReturnShipping(id, actionId, query, headers) {
    return __awaiter30(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/returns/${id}/shipping-method/${actionId}`, {
        method: "DELETE",
        headers,
        query
      });
    });
  }
  updateRequest(id, body, query, headers) {
    return __awaiter30(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/returns/${id}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  confirmRequest(id, body, query, headers) {
    return __awaiter30(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/returns/${id}/request`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  initiateReceive(id, body, query, headers) {
    return __awaiter30(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/returns/${id}/receive`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  receiveItems(id, body, query, headers) {
    return __awaiter30(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/returns/${id}/receive-items`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  updateReceiveItem(id, actionId, body, query, headers) {
    return __awaiter30(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/returns/${id}/receive-items/${actionId}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  removeReceiveItem(id, actionId, query, headers) {
    return __awaiter30(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/returns/${id}/receive-items/${actionId}`, {
        method: "DELETE",
        headers,
        query
      });
    });
  }
  dismissItems(id, body, query, headers) {
    return __awaiter30(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/returns/${id}/dismiss-items`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  updateDismissItem(id, actionId, body, query, headers) {
    return __awaiter30(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/returns/${id}/dismiss-items/${actionId}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  removeDismissItem(id, actionId, query, headers) {
    return __awaiter30(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/returns/${id}/dismiss-items/${actionId}`, {
        method: "DELETE",
        headers,
        query
      });
    });
  }
  confirmReceive(id, body, query, headers) {
    return __awaiter30(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/returns/${id}/receive/confirm`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  cancelReceive(id, query, headers) {
    return __awaiter30(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/returns/${id}/receive`, {
        method: "DELETE",
        headers,
        query
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/return-reason.js
var __awaiter31 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ReturnReason = class {
  constructor(client) {
    this.client = client;
  }
  list(query, headers) {
    return __awaiter31(this, void 0, void 0, function* () {
      return yield this.client.fetch("/admin/return-reasons", {
        headers,
        query
      });
    });
  }
  retrieve(id, query, headers) {
    return __awaiter31(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/return-reasons/${id}`, {
        query,
        headers
      });
    });
  }
  create(body, query, headers) {
    return __awaiter31(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/return-reasons`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  update(id, body, query, headers) {
    return __awaiter31(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/return-reasons/${id}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  delete(id, query, headers) {
    return __awaiter31(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/return-reasons/${id}`, {
        method: "DELETE",
        headers,
        query
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/sales-channel.js
var __awaiter32 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SalesChannel = class {
  constructor(client) {
    this.client = client;
  }
  create(body, query, headers) {
    return __awaiter32(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/sales-channels`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  update(id, body, query, headers) {
    return __awaiter32(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/sales-channels/${id}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  delete(id, headers) {
    return __awaiter32(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/sales-channels/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
  retrieve(id, query, headers) {
    return __awaiter32(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/sales-channels/${id}`, {
        method: "GET",
        headers,
        query
      });
    });
  }
  list(query, headers) {
    return __awaiter32(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/sales-channels`, {
        method: "GET",
        headers,
        query
      });
    });
  }
  updateProducts(id, body, headers) {
    return __awaiter32(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/sales-channels/${id}/products`, {
        method: "POST",
        headers,
        body
      });
    });
  }
  batchProducts(id, body, headers) {
    return __awaiter32(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/sales-channels/${id}/products`, {
        method: "POST",
        headers,
        body
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/shipping-option.js
var __awaiter33 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ShippingOption = class {
  constructor(client) {
    this.client = client;
  }
  create(body, query, headers) {
    return __awaiter33(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/shipping-options`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  retrieve(id, query, headers) {
    return __awaiter33(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/shipping-options/${id}`, {
        method: "GET",
        headers,
        query
      });
    });
  }
  update(id, body, query, headers) {
    return __awaiter33(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/shipping-options/${id}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  delete(id, headers) {
    return __awaiter33(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/shipping-options/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
  list(query, headers) {
    return __awaiter33(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/shipping-options`, {
        method: "GET",
        headers,
        query
      });
    });
  }
  updateRules(id, body, headers) {
    return __awaiter33(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/shipping-options/${id}/rules/batch`, {
        method: "POST",
        headers,
        body
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/shipping-profile.js
var __awaiter34 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ShippingProfile = class {
  constructor(client) {
    this.client = client;
  }
  create(body, query, headers) {
    return __awaiter34(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/shipping-profiles`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  update(id, body, query, headers) {
    return __awaiter34(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/shipping-profiles/${id}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  delete(id, headers) {
    return __awaiter34(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/shipping-profiles/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
  list(query, headers) {
    return __awaiter34(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/shipping-profiles`, {
        method: "GET",
        headers,
        query
      });
    });
  }
  retrieve(id, query, headers) {
    return __awaiter34(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/shipping-profiles/${id}`, {
        method: "GET",
        headers,
        query
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/stock-location.js
var __awaiter35 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var StockLocation = class {
  constructor(client) {
    this.client = client;
  }
  create(body, query, headers) {
    return __awaiter35(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/stock-locations`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  update(id, body, query, headers) {
    return __awaiter35(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/stock-locations/${id}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  delete(id, headers) {
    return __awaiter35(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/stock-locations/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
  retrieve(id, query, headers) {
    return __awaiter35(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/stock-locations/${id}`, {
        method: "GET",
        headers,
        query
      });
    });
  }
  list(query, headers) {
    return __awaiter35(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/stock-locations`, {
        method: "GET",
        headers,
        query
      });
    });
  }
  updateSalesChannels(id, body, headers) {
    return __awaiter35(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/stock-locations/${id}/sales-channels`, {
        method: "POST",
        headers,
        body
      });
    });
  }
  createFulfillmentSet(id, body, headers) {
    return __awaiter35(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/stock-locations/${id}/fulfillment-sets`, {
        method: "POST",
        headers,
        body
      });
    });
  }
  updateFulfillmentProviders(id, body, headers) {
    return __awaiter35(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/stock-locations/${id}/fulfillment-providers`, {
        method: "POST",
        headers,
        body
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/store.js
var __awaiter36 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Store = class {
  constructor(client) {
    this.client = client;
  }
  retrieve(id, query, headers) {
    return __awaiter36(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/stores/${id}`, {
        method: "GET",
        headers,
        query
      });
    });
  }
  list(query, headers) {
    return __awaiter36(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/stores`, {
        method: "GET",
        headers,
        query
      });
    });
  }
  update(id, body, query, headers) {
    return __awaiter36(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/stores/${id}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/tax-rate.js
var __awaiter37 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var taxRateUrl = "/admin/tax-rates";
var TaxRate = class {
  constructor(client) {
    this.client = client;
  }
  create(body, query, headers) {
    return __awaiter37(this, void 0, void 0, function* () {
      return yield this.client.fetch(taxRateUrl, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  update(id, body, query, headers) {
    return __awaiter37(this, void 0, void 0, function* () {
      return yield this.client.fetch(`${taxRateUrl}/${id}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  delete(id, headers) {
    return __awaiter37(this, void 0, void 0, function* () {
      return yield this.client.fetch(`${taxRateUrl}/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
  retrieve(id, query, headers) {
    return __awaiter37(this, void 0, void 0, function* () {
      return yield this.client.fetch(`${taxRateUrl}/${id}`, {
        method: "GET",
        headers,
        query
      });
    });
  }
  list(query, headers) {
    return __awaiter37(this, void 0, void 0, function* () {
      return yield this.client.fetch(taxRateUrl, {
        method: "GET",
        headers,
        query
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/tax-region.js
var __awaiter38 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var taxRegionUrl = "/admin/tax-regions";
var TaxRegion = class {
  constructor(client) {
    this.client = client;
  }
  create(body, query, headers) {
    return __awaiter38(this, void 0, void 0, function* () {
      return yield this.client.fetch(taxRegionUrl, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  delete(id, headers) {
    return __awaiter38(this, void 0, void 0, function* () {
      return yield this.client.fetch(`${taxRegionUrl}/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
  retrieve(id, query, headers) {
    return __awaiter38(this, void 0, void 0, function* () {
      return yield this.client.fetch(`${taxRegionUrl}/${id}`, {
        method: "GET",
        headers,
        query
      });
    });
  }
  list(query, headers) {
    return __awaiter38(this, void 0, void 0, function* () {
      return yield this.client.fetch(taxRegionUrl, {
        method: "GET",
        headers,
        query
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/upload.js
var __awaiter39 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Upload = class {
  constructor(client) {
    this.client = client;
  }
  // Note: The creation/upload flow be made more advanced, with support for streaming and progress, but for now we keep it simple
  create(body, query, headers) {
    return __awaiter39(this, void 0, void 0, function* () {
      const form = new FormData();
      if (body instanceof FileList) {
        Array.from(body).forEach((file) => {
          form.append("files", file);
        });
      } else {
        body.files.forEach((file) => {
          form.append("files", "content" in file ? new Blob([file.content], {
            type: "text/plain"
          }) : file, file.name);
        });
      }
      return this.client.fetch(`/admin/uploads`, {
        method: "POST",
        headers: Object.assign(Object.assign({}, headers), {
          // Let the browser determine the content type.
          "content-type": null
        }),
        body: form,
        query
      });
    });
  }
  retrieve(id, query, headers) {
    return __awaiter39(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/uploads/${id}`, {
        query,
        headers
      });
    });
  }
  delete(id, headers) {
    return __awaiter39(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/uploads/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/user.js
var __awaiter40 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var User = class {
  constructor(client) {
    this.client = client;
  }
  create(body, query, headers) {
    return __awaiter40(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/users`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  update(id, body, query, headers) {
    return __awaiter40(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/users/${id}`, {
        method: "POST",
        headers,
        body,
        query
      });
    });
  }
  list(queryParams, headers) {
    return __awaiter40(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/users`, {
        headers,
        query: queryParams
      });
    });
  }
  retrieve(id, query, headers) {
    return __awaiter40(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/users/${id}`, {
        query,
        headers
      });
    });
  }
  delete(id, headers) {
    return __awaiter40(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/users/${id}`, {
        method: "DELETE",
        headers
      });
    });
  }
  me(query, headers) {
    return __awaiter40(this, void 0, void 0, function* () {
      return this.client.fetch(`/admin/users/me`, {
        query,
        headers
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/workflow-execution.js
var __awaiter41 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var WorkflowExecution = class {
  constructor(client) {
    this.client = client;
  }
  list(queryParams, headers) {
    return __awaiter41(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/workflows-executions`, {
        query: queryParams,
        headers
      });
    });
  }
  retrieve(id, headers) {
    return __awaiter41(this, void 0, void 0, function* () {
      return yield this.client.fetch(`/admin/workflows-executions/${id}`, {
        headers
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/admin/index.js
var Admin = class {
  constructor(client) {
    this.invite = new Invite(client);
    this.customer = new Customer(client);
    this.productCollection = new ProductCollection(client);
    this.productCategory = new ProductCategory(client);
    this.priceList = new PriceList(client);
    this.pricePreference = new PricePreference(client);
    this.product = new Product(client);
    this.productType = new ProductType(client);
    this.upload = new Upload(client);
    this.region = new Region(client);
    this.returnReason = new ReturnReason(client);
    this.stockLocation = new StockLocation(client);
    this.salesChannel = new SalesChannel(client);
    this.fulfillmentSet = new FulfillmentSet(client);
    this.fulfillment = new Fulfillment(client);
    this.fulfillmentProvider = new FulfillmentProvider(client);
    this.shippingOption = new ShippingOption(client);
    this.shippingProfile = new ShippingProfile(client);
    this.inventoryItem = new InventoryItem(client);
    this.notification = new Notification(client);
    this.order = new Order(client);
    this.orderEdit = new OrderEdit(client);
    this.return = new Return(client);
    this.claim = new Claim(client);
    this.taxRate = new TaxRate(client);
    this.taxRegion = new TaxRegion(client);
    this.store = new Store(client);
    this.productTag = new ProductTag(client);
    this.user = new User(client);
    this.currency = new Currency(client);
    this.payment = new Payment(client);
    this.productVariant = new ProductVariant(client);
    this.refundReason = new RefundReason(client);
    this.exchange = new Exchange(client);
    this.paymentCollection = new PaymentCollection(client);
    this.apiKey = new ApiKey(client);
    this.workflowExecution = new WorkflowExecution(client);
    this.reservation = new reservation_default(client);
    this.customerGroup = new CustomerGroup(client);
    this.promotion = new Promotion(client);
    this.campaign = new Campaign(client);
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/auth/index.js
var __awaiter42 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Auth = class {
  constructor(client, config) {
    this.register = (actor, method, payload) => __awaiter42(this, void 0, void 0, function* () {
      const { token } = yield this.client.fetch(`/auth/${actor}/${method}/register`, {
        method: "POST",
        body: payload
      });
      this.client.setToken(token);
      return token;
    });
    this.login = (actor, method, payload) => __awaiter42(this, void 0, void 0, function* () {
      const { token, location } = yield this.client.fetch(`/auth/${actor}/${method}`, {
        method: "POST",
        body: payload
      });
      if (location) {
        return { location };
      }
      yield this.setToken_(token);
      return token;
    });
    this.callback = (actor, method, query) => __awaiter42(this, void 0, void 0, function* () {
      const { token } = yield this.client.fetch(`/auth/${actor}/${method}/callback`, {
        method: "GET",
        query
      });
      yield this.setToken_(token);
      return token;
    });
    this.refresh = () => __awaiter42(this, void 0, void 0, function* () {
      const { token } = yield this.client.fetch("/auth/token/refresh", {
        method: "POST"
      });
      yield this.setToken_(token);
      return token;
    });
    this.logout = () => __awaiter42(this, void 0, void 0, function* () {
      var _a11, _b;
      if (((_b = (_a11 = this.config) === null || _a11 === void 0 ? void 0 : _a11.auth) === null || _b === void 0 ? void 0 : _b.type) === "session") {
        yield this.client.fetch("/auth/session", {
          method: "DELETE"
        });
      }
      this.client.clearToken();
    });
    this.setToken_ = (token) => __awaiter42(this, void 0, void 0, function* () {
      var _a11, _b;
      if (((_b = (_a11 = this.config) === null || _a11 === void 0 ? void 0 : _a11.auth) === null || _b === void 0 ? void 0 : _b.type) === "session") {
        yield this.client.fetch("/auth/session", {
          method: "POST",
          headers: { Authorization: `Bearer ${token}` }
        });
      } else {
        this.client.setToken(token);
      }
    });
    this.client = client;
    this.config = config;
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/client.js
var import_qs = __toESM(require_lib());

// node_modules/fetch-event-stream/esm/deps/jsr.io/@std/streams/0.221.0/text_line_stream.js
var _currentLine;
var TextLineStream = class extends TransformStream {
  /** Constructs a new instance. */
  constructor(options = { allowCR: false }) {
    super({
      transform: (chars, controller) => {
        chars = __privateGet(this, _currentLine) + chars;
        while (true) {
          const lfIndex = chars.indexOf("\n");
          const crIndex = options.allowCR ? chars.indexOf("\r") : -1;
          if (crIndex !== -1 && crIndex !== chars.length - 1 && (lfIndex === -1 || lfIndex - 1 > crIndex)) {
            controller.enqueue(chars.slice(0, crIndex));
            chars = chars.slice(crIndex + 1);
            continue;
          }
          if (lfIndex === -1)
            break;
          const endIndex = chars[lfIndex - 1] === "\r" ? lfIndex - 1 : lfIndex;
          controller.enqueue(chars.slice(0, endIndex));
          chars = chars.slice(lfIndex + 1);
        }
        __privateSet(this, _currentLine, chars);
      },
      flush: (controller) => {
        if (__privateGet(this, _currentLine) === "")
          return;
        const currentLine = options.allowCR && __privateGet(this, _currentLine).endsWith("\r") ? __privateGet(this, _currentLine).slice(0, -1) : __privateGet(this, _currentLine);
        controller.enqueue(currentLine);
      }
    });
    __privateAdd(this, _currentLine, "");
  }
};
_currentLine = new WeakMap();

// node_modules/fetch-event-stream/esm/utils.js
function stream(input) {
  let decoder = new TextDecoderStream();
  let split2 = new TextLineStream({ allowCR: true });
  return input.pipeThrough(decoder).pipeThrough(split2);
}
function split(input) {
  let rgx = /[:]\s*/;
  let match = rgx.exec(input);
  let idx = match && match.index;
  if (idx) {
    return [
      input.substring(0, idx),
      input.substring(idx + match[0].length)
    ];
  }
}

// node_modules/fetch-event-stream/esm/mod.js
async function* events(res, signal) {
  if (!res.body)
    return;
  let iter = stream(res.body);
  let line, reader = iter.getReader();
  let event;
  for (; ; ) {
    if (signal && signal.aborted) {
      return reader.cancel();
    }
    line = await reader.read();
    if (line.done)
      return;
    if (!line.value) {
      if (event)
        yield event;
      event = void 0;
      continue;
    }
    let [field, value] = split(line.value) || [];
    if (!field)
      continue;
    if (field === "data") {
      event || (event = {});
      event[field] = event[field] ? event[field] + "\n" + value : value;
    } else if (field === "event") {
      event || (event = {});
      event[field] = value;
    } else if (field === "id") {
      event || (event = {});
      event[field] = +value || value;
    } else if (field === "retry") {
      event || (event = {});
      event[field] = +value || void 0;
    }
  }
}

// node_modules/@medusajs/js-sdk/dist/esm/client.js
var __awaiter43 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PUBLISHABLE_KEY_HEADER = "x-publishable-api-key";
var hasStorage = (storage) => {
  if (typeof window !== "undefined") {
    return storage in window;
  }
  return false;
};
var toBase64 = (str) => {
  if (typeof window !== "undefined") {
    return window.btoa(str);
  }
  return Buffer.from(str).toString("base64");
};
var sanitizeHeaders = (headers) => {
  return Object.assign(Object.assign({}, Object.fromEntries(headers.entries())), { authorization: "<REDACTED>" });
};
var normalizeRequest = (init, headers, config) => {
  var _a11, _b;
  let body = init === null || init === void 0 ? void 0 : init.body;
  if (body && ((_a11 = headers.get("content-type")) === null || _a11 === void 0 ? void 0 : _a11.includes("application/json"))) {
    body = JSON.stringify(body);
  }
  return Object.assign(Object.assign(Object.assign({}, init), {
    headers,
    // TODO: Setting this to "include" poses some security risks, as it will send cookies to any domain. We should consider making this configurable.
    credentials: ((_b = config.auth) === null || _b === void 0 ? void 0 : _b.type) === "session" ? "include" : "omit"
  }), body ? { body } : {});
};
var normalizeResponse = (resp, reqHeaders) => __awaiter43(void 0, void 0, void 0, function* () {
  var _a11, _b;
  if (resp.status >= 300) {
    const jsonError = yield resp.json().catch(() => ({}));
    throw new FetchError((_a11 = jsonError.message) !== null && _a11 !== void 0 ? _a11 : resp.statusText, resp.statusText, resp.status);
  }
  const isJsonRequest = (_b = reqHeaders.get("accept")) === null || _b === void 0 ? void 0 : _b.includes("application/json");
  return isJsonRequest ? yield resp.json() : resp;
});
var FetchError = class extends Error {
  constructor(message, statusText, status) {
    super(message);
    this.statusText = statusText;
    this.status = status;
  }
};
var Client = class {
  constructor(config) {
    this.DEFAULT_JWT_STORAGE_KEY = "medusa_auth_token";
    this.token = "";
    this.getApiKeyHeader_ = () => {
      return this.config.apiKey ? { Authorization: "Basic " + toBase64(this.config.apiKey + ":") } : {};
    };
    this.getPublishableKeyHeader_ = () => {
      return this.config.publishableKey ? { [PUBLISHABLE_KEY_HEADER]: this.config.publishableKey } : {};
    };
    this.getJwtHeader_ = () => {
      var _a11;
      if (((_a11 = this.config.auth) === null || _a11 === void 0 ? void 0 : _a11.type) === "session") {
        return {};
      }
      const token = this.getToken_();
      return token ? { Authorization: `Bearer ${token}` } : {};
    };
    this.setToken_ = (token) => {
      const { storageMethod, storageKey } = this.getTokenStorageInfo_();
      switch (storageMethod) {
        case "local": {
          window.localStorage.setItem(storageKey, token);
          break;
        }
        case "session": {
          window.sessionStorage.setItem(storageKey, token);
          break;
        }
        case "memory": {
          this.token = token;
          break;
        }
      }
    };
    this.getToken_ = () => {
      const { storageMethod, storageKey } = this.getTokenStorageInfo_();
      switch (storageMethod) {
        case "local": {
          return window.localStorage.getItem(storageKey);
        }
        case "session": {
          return window.sessionStorage.getItem(storageKey);
        }
        case "memory": {
          return this.token;
        }
      }
      return;
    };
    this.getTokenStorageInfo_ = () => {
      var _a11, _b;
      const hasLocal = hasStorage("localStorage");
      const hasSession = hasStorage("sessionStorage");
      const storageMethod = ((_a11 = this.config.auth) === null || _a11 === void 0 ? void 0 : _a11.jwtTokenStorageMethod) || (hasLocal ? "local" : "memory");
      const storageKey = ((_b = this.config.auth) === null || _b === void 0 ? void 0 : _b.jwtTokenStorageKey) || this.DEFAULT_JWT_STORAGE_KEY;
      if (!hasLocal && storageMethod === "local") {
        throw new Error("Local JWT storage is only available in the browser");
      }
      if (!hasSession && storageMethod === "session") {
        throw new Error("Session JWT storage is only available in the browser");
      }
      return {
        storageMethod,
        storageKey
      };
    };
    this.config = config;
    const logger = config.logger || {
      error: console.error,
      warn: console.warn,
      info: console.info,
      debug: console.debug
    };
    this.logger = Object.assign(Object.assign({}, logger), { debug: config.debug ? logger.debug : () => {
    } });
    this.fetch_ = this.initClient();
  }
  /**
   * `fetch` closely follows (and uses under the hood) the native `fetch` API. There are, however, few key differences:
   * - Non 2xx statuses throw a `FetchError` with the status code as the `status` property, rather than resolving the promise
   * - You can pass `body` and `query` as objects, and they will be encoded and stringified.
   * - The response gets parsed as JSON if the `accept` header is set to `application/json`, otherwise the raw Response object is returned
   *
   * Since the response is dynamically determined, we cannot know if it is JSON or not. Therefore, it is important to pass `Response` as the return type
   *
   * @param input: FetchInput
   * @param init: FetchArgs
   * @returns Promise<T>
   */
  fetch(input, init) {
    return this.fetch_(input, init);
  }
  /**
   * `fetchStream` is a helper method to deal with server-sent events. It returns an object with a stream and an abort function.
   * It follows a very similar interface to `fetch`, with the return value being an async generator.
   * The stream is an async generator that yields `ServerSentEventMessage` objects, which contains the event name, stringified data, and few other properties.
   * The caller is responsible for handling `disconnect` events and aborting the stream. The caller is also responsible for parsing the data field.
   *
   * @param input: FetchInput
   * @param init: FetchArgs
   * @returns FetchStreamResponse
   */
  fetchStream(input, init) {
    return __awaiter43(this, void 0, void 0, function* () {
      const abortController = new AbortController();
      const abortFunc = abortController.abort.bind(abortController);
      let res = yield this.fetch_(input, Object.assign(Object.assign({}, init), { signal: abortController.signal, headers: Object.assign(Object.assign({}, init === null || init === void 0 ? void 0 : init.headers), { accept: "text/event-stream" }) }));
      if (res.ok) {
        return { stream: events(res, abortController.signal), abort: abortFunc };
      }
      return { stream: null, abort: abortFunc };
    });
  }
  setToken(token) {
    this.setToken_(token);
  }
  clearToken() {
    this.clearToken_();
  }
  clearToken_() {
    const { storageMethod, storageKey } = this.getTokenStorageInfo_();
    switch (storageMethod) {
      case "local": {
        window.localStorage.removeItem(storageKey);
        break;
      }
      case "session": {
        window.sessionStorage.removeItem(storageKey);
        break;
      }
      case "memory": {
        this.token = "";
        break;
      }
    }
  }
  initClient() {
    const defaultHeaders = new Headers(Object.assign(Object.assign({ "content-type": "application/json", accept: "application/json" }, this.getApiKeyHeader_()), this.getPublishableKeyHeader_()));
    this.logger.debug("Initiating Medusa client with default headers:\n", `${JSON.stringify(sanitizeHeaders(defaultHeaders), null, 2)}
`);
    return (input, init) => __awaiter43(this, void 0, void 0, function* () {
      const headers = new Headers(defaultHeaders);
      const customHeaders = Object.assign(Object.assign(Object.assign({}, this.config.globalHeaders), this.getJwtHeader_()), init === null || init === void 0 ? void 0 : init.headers);
      Object.entries(customHeaders).forEach(([key, value]) => {
        if (value === null) {
          headers.delete(key);
        } else {
          headers.set(key, value);
        }
      });
      let normalizedInput = input;
      if (input instanceof URL || typeof input === "string") {
        normalizedInput = new URL(input, this.config.baseUrl);
        if (init === null || init === void 0 ? void 0 : init.query) {
          const params = Object.fromEntries(normalizedInput.searchParams.entries());
          const stringifiedQuery = import_qs.default.stringify(Object.assign(Object.assign({}, params), init.query));
          normalizedInput.search = stringifiedQuery;
        }
      }
      this.logger.debug("Performing request to:\n", `URL: ${normalizedInput.toString()}
`, `Headers: ${JSON.stringify(sanitizeHeaders(headers), null, 2)}
`);
      return yield fetch(normalizedInput, normalizeRequest(init, headers, this.config)).then((resp) => {
        this.logger.debug(`Received response with status ${resp.status}
`);
        return normalizeResponse(resp, headers);
      });
    });
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/store/index.js
var __awaiter44 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Store2 = class {
  constructor(client) {
    this.region = {
      list: (query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/regions`, {
          query,
          headers
        });
      }),
      retrieve: (id, query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/regions/${id}`, {
          query,
          headers
        });
      })
    };
    this.collection = {
      list: (query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/collections`, {
          query,
          headers
        });
      }),
      retrieve: (id, query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/collections/${id}`, {
          query,
          headers
        });
      })
    };
    this.category = {
      list: (query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/product-categories`, {
          query,
          headers
        });
      }),
      retrieve: (id, query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/product-categories/${id}`, {
          query,
          headers
        });
      })
    };
    this.product = {
      list: (query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/products`, {
          query,
          headers
        });
      }),
      retrieve: (id, query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/products/${id}`, {
          query,
          headers
        });
      })
    };
    this.cart = {
      create: (body, query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/carts`, {
          method: "POST",
          headers,
          body,
          query
        });
      }),
      update: (id, body, query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/carts/${id}`, {
          method: "POST",
          headers,
          body,
          query
        });
      }),
      retrieve: (id, query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/carts/${id}`, {
          headers,
          query
        });
      }),
      createLineItem: (cartId, body, query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/carts/${cartId}/line-items`, {
          method: "POST",
          headers,
          body,
          query
        });
      }),
      updateLineItem: (cartId, lineItemId, body, query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/carts/${cartId}/line-items/${lineItemId}`, {
          method: "POST",
          headers,
          body,
          query
        });
      }),
      deleteLineItem: (cartId, lineItemId, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/carts/${cartId}/line-items/${lineItemId}`, {
          method: "DELETE",
          headers
        });
      }),
      addShippingMethod: (cartId, body, query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/carts/${cartId}/shipping-methods`, {
          method: "POST",
          headers,
          body,
          query
        });
      }),
      complete: (cartId, query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/carts/${cartId}/complete`, {
          method: "POST",
          headers,
          query
        });
      })
    };
    this.fulfillment = {
      listCartOptions: (query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/shipping-options`, {
          headers,
          query
        });
      })
    };
    this.payment = {
      listPaymentProviders: (query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/payment-providers`, {
          headers,
          query
        });
      }),
      initiatePaymentSession: (cart, body, query, headers) => __awaiter44(this, void 0, void 0, function* () {
        var _a11;
        let paymentCollectionId = (_a11 = cart.payment_collection) === null || _a11 === void 0 ? void 0 : _a11.id;
        if (!paymentCollectionId) {
          const collectionBody = {
            cart_id: cart.id
          };
          paymentCollectionId = (yield this.client.fetch(`/store/payment-collections`, {
            method: "POST",
            headers,
            body: collectionBody
          })).payment_collection.id;
        }
        return this.client.fetch(`/store/payment-collections/${paymentCollectionId}/payment-sessions`, {
          method: "POST",
          headers,
          body,
          query
        });
      })
    };
    this.order = {
      list: (query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/orders`, {
          query,
          headers
        });
      }),
      retrieve: (id, query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/orders/${id}`, {
          headers,
          query
        });
      })
    };
    this.customer = {
      create: (body, query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/customers`, {
          method: "POST",
          headers,
          body,
          query
        });
      }),
      update: (body, query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/customers/me`, {
          method: "POST",
          headers,
          body,
          query
        });
      }),
      retrieve: (query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/customers/me`, {
          query,
          headers
        });
      }),
      createAddress: (body, query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/customers/me/addresses`, {
          method: "POST",
          headers,
          body,
          query
        });
      }),
      updateAddress: (addressId, body, query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/customers/me/addresses/${addressId}`, {
          method: "POST",
          headers,
          body,
          query
        });
      }),
      listAddress: (query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/customers/me/addresses`, {
          query,
          headers
        });
      }),
      retrieveAddress: (addressId, query, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/customers/me/addresses/${addressId}`, {
          query,
          headers
        });
      }),
      deleteAddress: (addressId, headers) => __awaiter44(this, void 0, void 0, function* () {
        return this.client.fetch(`/store/customers/me/addresses/${addressId}`, {
          method: "DELETE",
          headers
        });
      })
    };
    this.client = client;
  }
};

// node_modules/@medusajs/js-sdk/dist/esm/index.js
var Medusa = class {
  constructor(config) {
    this.client = new Client(config);
    this.admin = new Admin(this.client);
    this.store = new Store2(this.client);
    this.auth = new Auth(this.client, config);
  }
};
var esm_default = Medusa;

// node_modules/@medusajs/dashboard/dist/chunk-PWWSB76U.mjs
var backendUrl = __BACKEND_URL__ ?? "http://localhost:9000";
var sdk = new esm_default({
  baseUrl: backendUrl,
  auth: {
    type: "session"
  }
});
if (typeof window !== "undefined") {
  ;
  window.__sdk = sdk;
}

export {
  keepPreviousData,
  QueryClient,
  QueryClientProvider,
  useQuery,
  useMutation,
  useInfiniteQuery,
  FetchError,
  sdk
};
//# sourceMappingURL=chunk-ZSXFNTF6.js.map
